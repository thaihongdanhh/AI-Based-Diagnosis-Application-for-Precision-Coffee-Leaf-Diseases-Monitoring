{"ast":null,"code":"import invariant from 'invariant';\nexport class CellRenderMask {\n  constructor(numCells) {\n    invariant(numCells >= 0, 'CellRenderMask must contain a non-negative number os cells');\n    this._numCells = numCells;\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [{\n        first: 0,\n        last: numCells - 1,\n        isSpacer: true\n      }];\n    }\n  }\n  enumerateRegions() {\n    return this._regions;\n  }\n  addCells(cells) {\n    invariant(cells.first >= 0 && cells.first < this._numCells && cells.last >= -1 && cells.last < this._numCells && cells.last >= cells.first - 1, 'CellRenderMask.addCells called with invalid cell range');\n    if (cells.last < cells.first) {\n      return;\n    }\n    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first);\n    const [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);\n    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n      return;\n    }\n    const newLeadRegion = [];\n    const newTailRegion = [];\n    const newMainRegion = Object.assign({}, cells, {\n      isSpacer: false\n    });\n    if (firstIntersect.first < newMainRegion.first) {\n      if (firstIntersect.isSpacer) {\n        newLeadRegion.push({\n          first: firstIntersect.first,\n          last: newMainRegion.first - 1,\n          isSpacer: true\n        });\n      } else {\n        newMainRegion.first = firstIntersect.first;\n      }\n    }\n    if (lastIntersect.last > newMainRegion.last) {\n      if (lastIntersect.isSpacer) {\n        newTailRegion.push({\n          first: newMainRegion.last + 1,\n          last: lastIntersect.last,\n          isSpacer: true\n        });\n      } else {\n        newMainRegion.last = lastIntersect.last;\n      }\n    }\n    const replacementRegions = [...newLeadRegion, newMainRegion, ...newTailRegion];\n    const numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n    this._regions.splice(firstIntersectIdx, numRegionsToDelete, ...replacementRegions);\n  }\n  numCells() {\n    return this._numCells;\n  }\n  equals(other) {\n    return this._numCells === other._numCells && this._regions.length === other._regions.length && this._regions.every((region, i) => region.first === other._regions[i].first && region.last === other._regions[i].last && region.isSpacer === other._regions[i].isSpacer);\n  }\n  _findRegion(cellIdx) {\n    let firstIdx = 0;\n    let lastIdx = this._regions.length - 1;\n    while (firstIdx <= lastIdx) {\n      const middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n      const middleRegion = this._regions[middleIdx];\n      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n        return [middleRegion, middleIdx];\n      } else if (cellIdx < middleRegion.first) {\n        lastIdx = middleIdx - 1;\n      } else if (cellIdx > middleRegion.last) {\n        firstIdx = middleIdx + 1;\n      }\n    }\n    invariant(false, `A region was not found containing cellIdx ${cellIdx}`);\n  }\n}","map":{"version":3,"names":["invariant","CellRenderMask","constructor","numCells","_numCells","_regions","first","last","isSpacer","enumerateRegions","addCells","cells","firstIntersect","firstIntersectIdx","_findRegion","lastIntersect","lastIntersectIdx","newLeadRegion","newTailRegion","newMainRegion","Object","assign","push","replacementRegions","numRegionsToDelete","splice","equals","other","length","every","region","i","cellIdx","firstIdx","lastIdx","middleIdx","Math","floor","middleRegion"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/@react-native/virtualized-lists/Lists/CellRenderMask.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport invariant from 'invariant';\n\nexport type CellRegion = {\n  first: number,\n  last: number,\n  isSpacer: boolean,\n};\n\nexport class CellRenderMask {\n  _numCells: number;\n  _regions: Array<CellRegion>;\n\n  constructor(numCells: number) {\n    invariant(\n      numCells >= 0,\n      'CellRenderMask must contain a non-negative number os cells',\n    );\n\n    this._numCells = numCells;\n\n    if (numCells === 0) {\n      this._regions = [];\n    } else {\n      this._regions = [\n        {\n          first: 0,\n          last: numCells - 1,\n          isSpacer: true,\n        },\n      ];\n    }\n  }\n\n  enumerateRegions(): $ReadOnlyArray<CellRegion> {\n    return this._regions;\n  }\n\n  addCells(cells: {first: number, last: number}): void {\n    invariant(\n      cells.first >= 0 &&\n        cells.first < this._numCells &&\n        cells.last >= -1 &&\n        cells.last < this._numCells &&\n        cells.last >= cells.first - 1,\n      'CellRenderMask.addCells called with invalid cell range',\n    );\n\n    // VirtualizedList uses inclusive ranges, where zero-count states are\n    // possible. E.g. [0, -1] for no cells, starting at 0.\n    if (cells.last < cells.first) {\n      return;\n    }\n\n    const [firstIntersect, firstIntersectIdx] = this._findRegion(cells.first);\n    const [lastIntersect, lastIntersectIdx] = this._findRegion(cells.last);\n\n    // Fast-path if the cells to add are already all present in the mask. We\n    // will otherwise need to do some mutation.\n    if (firstIntersectIdx === lastIntersectIdx && !firstIntersect.isSpacer) {\n      return;\n    }\n\n    // We need to replace the existing covered regions with 1-3 new regions\n    // depending whether we need to split spacers out of overlapping regions.\n    const newLeadRegion: Array<CellRegion> = [];\n    const newTailRegion: Array<CellRegion> = [];\n    const newMainRegion: CellRegion = {\n      ...cells,\n      isSpacer: false,\n    };\n\n    if (firstIntersect.first < newMainRegion.first) {\n      if (firstIntersect.isSpacer) {\n        newLeadRegion.push({\n          first: firstIntersect.first,\n          last: newMainRegion.first - 1,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.first = firstIntersect.first;\n      }\n    }\n\n    if (lastIntersect.last > newMainRegion.last) {\n      if (lastIntersect.isSpacer) {\n        newTailRegion.push({\n          first: newMainRegion.last + 1,\n          last: lastIntersect.last,\n          isSpacer: true,\n        });\n      } else {\n        newMainRegion.last = lastIntersect.last;\n      }\n    }\n\n    const replacementRegions: Array<CellRegion> = [\n      ...newLeadRegion,\n      newMainRegion,\n      ...newTailRegion,\n    ];\n    const numRegionsToDelete = lastIntersectIdx - firstIntersectIdx + 1;\n    this._regions.splice(\n      firstIntersectIdx,\n      numRegionsToDelete,\n      ...replacementRegions,\n    );\n  }\n\n  numCells(): number {\n    return this._numCells;\n  }\n\n  equals(other: CellRenderMask): boolean {\n    return (\n      this._numCells === other._numCells &&\n      this._regions.length === other._regions.length &&\n      this._regions.every(\n        (region, i) =>\n          region.first === other._regions[i].first &&\n          region.last === other._regions[i].last &&\n          region.isSpacer === other._regions[i].isSpacer,\n      )\n    );\n  }\n\n  _findRegion(cellIdx: number): [CellRegion, number] {\n    let firstIdx = 0;\n    let lastIdx = this._regions.length - 1;\n\n    while (firstIdx <= lastIdx) {\n      const middleIdx = Math.floor((firstIdx + lastIdx) / 2);\n      const middleRegion = this._regions[middleIdx];\n\n      if (cellIdx >= middleRegion.first && cellIdx <= middleRegion.last) {\n        return [middleRegion, middleIdx];\n      } else if (cellIdx < middleRegion.first) {\n        lastIdx = middleIdx - 1;\n      } else if (cellIdx > middleRegion.last) {\n        firstIdx = middleIdx + 1;\n      }\n    }\n\n    invariant(false, `A region was not found containing cellIdx ${cellIdx}`);\n  }\n}\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}