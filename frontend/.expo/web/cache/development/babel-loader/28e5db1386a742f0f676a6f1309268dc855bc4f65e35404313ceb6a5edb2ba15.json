{"ast":null,"code":"import { Platform } from 'expo-modules-core';\nexport const userMediaRequested = false;\nexport const mountedInstances = [];\nasync function requestLegacyUserMediaAsync(props) {\n  const optionalSource = id => ({\n    optional: [{\n      sourceId: id\n    }]\n  });\n  const constraintToSourceId = constraint => {\n    const {\n      deviceId\n    } = constraint;\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n    if (Array.isArray(deviceId) && deviceId.length > 0) {\n      return deviceId[0];\n    }\n    if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n    return null;\n  };\n  const sources = await new Promise(resolve => MediaStreamTrack.getSources(sources => resolve(sources)));\n  let audioSource = null;\n  let videoSource = null;\n  sources.forEach(source => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\nasync function sourceSelectedAsync(isMuted, audioConstraints, videoConstraints) {\n  const constraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true\n  };\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n  return await getAnyUserMediaAsync(constraints);\n}\nexport async function requestUserMediaAsync(props, isMuted = true) {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n  const [audio, video] = await requestLegacyUserMediaAsync(props);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\nexport async function getAnyUserMediaAsync(constraints, ignoreConstraints = false) {\n  try {\n    return await getUserMediaAsync(Object.assign({}, constraints, {\n      video: ignoreConstraints || constraints.video\n    }));\n  } catch (error) {\n    if (!ignoreConstraints && error.name === 'ConstraintNotSatisfiedError') {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n    throw error;\n  }\n}\nexport async function getUserMediaAsync(constraints) {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n  const _getUserMedia = navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'];\n  return new Promise((resolve, reject) => _getUserMedia.call(navigator, constraints, resolve, reject));\n}\nexport function canGetUserMedia() {\n  return Platform.isDOMAvailable && !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia || navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia']);\n}\nexport async function isFrontCameraAvailableAsync(devices) {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\nexport async function isBackCameraAvailableAsync(devices) {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\nasync function supportsCameraType(labels, type, devices) {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n  const cameras = devices.filter(t => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter(camera => labels.some(label => camera.label.toLowerCase().includes(label)));\n  const [isCapable] = cameras.filter(camera => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n    const capabilities = camera.getCapabilities();\n    if (!capabilities.facingMode) {\n      return null;\n    }\n    return capabilities.facingMode.find(_ => type);\n  });\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}","map":{"version":3,"names":["Platform","userMediaRequested","mountedInstances","requestLegacyUserMediaAsync","props","optionalSource","id","optional","sourceId","constraintToSourceId","constraint","deviceId","Array","isArray","length","ideal","sources","Promise","resolve","MediaStreamTrack","getSources","audioSource","videoSource","forEach","source","kind","audioSourceId","audioConstraints","videoSourceId","videoConstraints","sourceSelectedAsync","isMuted","constraints","video","audio","getAnyUserMediaAsync","requestUserMediaAsync","canGetUserMedia","ignoreConstraints","getUserMediaAsync","Object","assign","error","name","navigator","mediaDevices","getUserMedia","_getUserMedia","reject","call","isDOMAvailable","isFrontCameraAvailableAsync","devices","supportsCameraType","isBackCameraAvailableAsync","labels","type","enumerateDevices","cameras","filter","t","hasCamera","camera","some","label","toLowerCase","includes","isCapable","capabilities","getCapabilities","facingMode","find","_"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/expo-camera/src/web/WebUserMediaManager.ts"],"sourcesContent":["/* eslint-env browser */\n/**\n * A web-only module for ponyfilling the UserMedia API.\n */\nimport { Platform } from 'expo-modules-core';\n\nexport const userMediaRequested: boolean = false;\n\nexport const mountedInstances: any[] = [];\n\nasync function requestLegacyUserMediaAsync(props): Promise<any[]> {\n  const optionalSource = (id) => ({ optional: [{ sourceId: id }] });\n\n  const constraintToSourceId = (constraint) => {\n    const { deviceId } = constraint;\n\n    if (typeof deviceId === 'string') {\n      return deviceId;\n    }\n\n    if (Array.isArray(deviceId) && deviceId.length > 0) {\n      return deviceId[0];\n    }\n\n    if (typeof deviceId === 'object' && deviceId.ideal) {\n      return deviceId.ideal;\n    }\n\n    return null;\n  };\n\n  const sources: any[] = await new Promise((resolve) =>\n    // @ts-ignore: https://caniuse.com/#search=getSources Chrome for Android (78) & Samsung Internet (10.1) use this\n    MediaStreamTrack.getSources((sources) => resolve(sources))\n  );\n\n  let audioSource = null;\n  let videoSource = null;\n\n  sources.forEach((source) => {\n    if (source.kind === 'audio') {\n      audioSource = source.id;\n    } else if (source.kind === 'video') {\n      videoSource = source.id;\n    }\n  });\n\n  const audioSourceId = constraintToSourceId(props.audioConstraints);\n  if (audioSourceId) {\n    audioSource = audioSourceId;\n  }\n\n  const videoSourceId = constraintToSourceId(props.videoConstraints);\n  if (videoSourceId) {\n    videoSource = videoSourceId;\n  }\n\n  return [optionalSource(audioSource), optionalSource(videoSource)];\n}\n\nasync function sourceSelectedAsync(\n  isMuted: boolean,\n  audioConstraints?: MediaTrackConstraints | boolean,\n  videoConstraints?: MediaTrackConstraints | boolean\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = {\n    video: typeof videoConstraints !== 'undefined' ? videoConstraints : true,\n  };\n\n  if (!isMuted) {\n    constraints.audio = typeof audioConstraints !== 'undefined' ? audioConstraints : true;\n  }\n\n  return await getAnyUserMediaAsync(constraints);\n}\n\nexport async function requestUserMediaAsync(\n  props: { audio?: any; video?: any },\n  isMuted: boolean = true\n): Promise<MediaStream> {\n  if (canGetUserMedia()) {\n    return await sourceSelectedAsync(isMuted, props.audio, props.video);\n  }\n  const [audio, video] = await requestLegacyUserMediaAsync(props);\n  return await sourceSelectedAsync(isMuted, audio, video);\n}\n\nexport async function getAnyUserMediaAsync(\n  constraints: MediaStreamConstraints,\n  ignoreConstraints: boolean = false\n): Promise<MediaStream> {\n  try {\n    return await getUserMediaAsync({\n      ...constraints,\n      video: ignoreConstraints || constraints.video,\n    });\n  } catch (error) {\n    if (!ignoreConstraints && error.name === 'ConstraintNotSatisfiedError') {\n      return await getAnyUserMediaAsync(constraints, true);\n    }\n    throw error;\n  }\n}\n\nexport async function getUserMediaAsync(constraints: MediaStreamConstraints): Promise<MediaStream> {\n  if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n    return navigator.mediaDevices.getUserMedia(constraints);\n  }\n\n  const _getUserMedia =\n    navigator['mozGetUserMedia'] || navigator['webkitGetUserMedia'] || navigator['msGetUserMedia'];\n  return new Promise((resolve, reject) =>\n    _getUserMedia.call(navigator, constraints, resolve, reject)\n  );\n}\n\nexport function canGetUserMedia(): boolean {\n  return (\n    // SSR\n    Platform.isDOMAvailable &&\n    // Has any form of media API\n    !!(\n      (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) ||\n      navigator['mozGetUserMedia'] ||\n      navigator['webkitGetUserMedia'] ||\n      navigator['msGetUserMedia']\n    )\n  );\n}\n\nexport async function isFrontCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['front', 'user', 'facetime'], 'user', devices);\n}\n\nexport async function isBackCameraAvailableAsync(\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  return await supportsCameraType(['back', 'rear'], 'environment', devices);\n}\n\nasync function supportsCameraType(\n  labels: string[],\n  type: string,\n  devices?: MediaDeviceInfo[]\n): Promise<null | string> {\n  if (!devices) {\n    if (!navigator.mediaDevices.enumerateDevices) {\n      return null;\n    }\n    devices = await navigator.mediaDevices.enumerateDevices();\n  }\n  const cameras = devices.filter((t) => t.kind === 'videoinput');\n  const [hasCamera] = cameras.filter((camera) =>\n    labels.some((label) => camera.label.toLowerCase().includes(label))\n  );\n  const [isCapable] = cameras.filter((camera) => {\n    if (!('getCapabilities' in camera)) {\n      return null;\n    }\n\n    const capabilities = (camera as any).getCapabilities();\n    if (!capabilities.facingMode) {\n      return null;\n    }\n\n    return capabilities.facingMode.find((_: string) => type);\n  });\n\n  return isCapable?.deviceId || hasCamera?.deviceId || null;\n}\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}