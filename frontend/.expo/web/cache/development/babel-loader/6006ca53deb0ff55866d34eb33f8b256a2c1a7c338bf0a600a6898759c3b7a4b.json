{"ast":null,"code":"import { PermissionStatus, UnavailabilityError } from 'expo-modules-core';\nimport { LocationAccuracy } from \"./Location.types\";\nimport { LocationEventEmitter } from \"./LocationEventEmitter\";\nclass GeocoderError extends Error {\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\nfunction geolocationPositionToJSON(position) {\n  const {\n    coords,\n    timestamp\n  } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed\n    },\n    timestamp\n  };\n}\nfunction isLocationValid(location, options) {\n  const maxAge = typeof options.maxAge === 'number' ? options.maxAge : Infinity;\n  const requiredAccuracy = typeof options.requiredAccuracy === 'number' ? options.requiredAccuracy : Infinity;\n  const locationAccuracy = location.coords.accuracy ?? Infinity;\n  return Date.now() - location.timestamp <= maxAge && locationAccuracy <= requiredAccuracy;\n}\nasync function getPermissionsAsync(shouldAsk = false) {\n  if (!navigator?.permissions?.query) {\n    throw new UnavailabilityError('expo-location', 'navigator.permissions API is not available');\n  }\n  const permission = await navigator.permissions.query({\n    name: 'geolocation'\n  });\n  if (permission.state === 'granted') {\n    return {\n      status: PermissionStatus.GRANTED,\n      granted: true,\n      canAskAgain: true,\n      expires: 0\n    };\n  }\n  if (permission.state === 'denied') {\n    return {\n      status: PermissionStatus.DENIED,\n      granted: false,\n      canAskAgain: true,\n      expires: 0\n    };\n  }\n  if (shouldAsk) {\n    return new Promise(resolve => {\n      navigator.geolocation.getCurrentPosition(() => {\n        resolve({\n          status: PermissionStatus.GRANTED,\n          granted: true,\n          canAskAgain: true,\n          expires: 0\n        });\n      }, positionError => {\n        if (positionError.code === positionError.PERMISSION_DENIED) {\n          resolve({\n            status: PermissionStatus.DENIED,\n            granted: false,\n            canAskAgain: true,\n            expires: 0\n          });\n          return;\n        }\n        resolve({\n          status: PermissionStatus.GRANTED,\n          granted: false,\n          canAskAgain: true,\n          expires: 0\n        });\n      });\n    });\n  }\n  return {\n    status: PermissionStatus.UNDETERMINED,\n    granted: false,\n    canAskAgain: true,\n    expires: 0\n  };\n}\nlet lastKnownPosition = null;\nexport default {\n  async getProviderStatusAsync() {\n    return {\n      locationServicesEnabled: 'geolocation' in navigator\n    };\n  },\n  async getLastKnownPositionAsync(options = {}) {\n    if (lastKnownPosition && isLocationValid(lastKnownPosition, options)) {\n      return lastKnownPosition;\n    }\n    return null;\n  },\n  async getCurrentPositionAsync(options) {\n    return new Promise((resolve, reject) => {\n      const resolver = position => {\n        lastKnownPosition = geolocationPositionToJSON(position);\n        resolve(lastKnownPosition);\n      };\n      navigator.geolocation.getCurrentPosition(resolver, reject, Object.assign({\n        maximumAge: Infinity,\n        enableHighAccuracy: (options.accuracy ?? 0) > LocationAccuracy.Balanced\n      }, options));\n    });\n  },\n  async removeWatchAsync(watchId) {\n    navigator.geolocation.clearWatch(watchId);\n  },\n  async watchDeviceHeading(headingId) {\n    console.warn('Location.watchDeviceHeading: is not supported on web');\n  },\n  async hasServicesEnabledAsync() {\n    return 'geolocation' in navigator;\n  },\n  async geocodeAsync() {\n    throw new GeocoderError();\n  },\n  async reverseGeocodeAsync() {\n    throw new GeocoderError();\n  },\n  async watchPositionImplAsync(watchId, options) {\n    return new Promise(resolve => {\n      watchId = global.navigator.geolocation.watchPosition(position => {\n        lastKnownPosition = geolocationPositionToJSON(position);\n        LocationEventEmitter.emit('Expo.locationChanged', {\n          watchId,\n          location: lastKnownPosition\n        });\n      }, undefined, options);\n      resolve(watchId);\n    });\n  },\n  async requestForegroundPermissionsAsync() {\n    return getPermissionsAsync(true);\n  },\n  async requestBackgroundPermissionsAsync() {\n    return getPermissionsAsync(true);\n  },\n  async getForegroundPermissionsAsync() {\n    return getPermissionsAsync();\n  },\n  async getBackgroundPermissionsAsync() {\n    return getPermissionsAsync();\n  }\n};","map":{"version":3,"names":["PermissionStatus","UnavailabilityError","LocationAccuracy","LocationEventEmitter","GeocoderError","Error","constructor","code","geolocationPositionToJSON","position","coords","timestamp","latitude","longitude","altitude","accuracy","altitudeAccuracy","heading","speed","isLocationValid","location","options","maxAge","Infinity","requiredAccuracy","locationAccuracy","Date","now","getPermissionsAsync","shouldAsk","navigator","permissions","query","permission","name","state","status","GRANTED","granted","canAskAgain","expires","DENIED","Promise","resolve","geolocation","getCurrentPosition","positionError","PERMISSION_DENIED","UNDETERMINED","lastKnownPosition","getProviderStatusAsync","locationServicesEnabled","getLastKnownPositionAsync","getCurrentPositionAsync","reject","resolver","Object","assign","maximumAge","enableHighAccuracy","Balanced","removeWatchAsync","watchId","clearWatch","watchDeviceHeading","headingId","console","warn","hasServicesEnabledAsync","geocodeAsync","reverseGeocodeAsync","watchPositionImplAsync","global","watchPosition","emit","undefined","requestForegroundPermissionsAsync","requestBackgroundPermissionsAsync","getForegroundPermissionsAsync","getBackgroundPermissionsAsync"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/expo-location/src/ExpoLocation.web.ts"],"sourcesContent":["import { PermissionResponse, PermissionStatus, UnavailabilityError } from 'expo-modules-core';\n\nimport {\n  LocationAccuracy,\n  LocationLastKnownOptions,\n  LocationObject,\n  LocationOptions,\n} from './Location.types';\nimport { LocationEventEmitter } from './LocationEventEmitter';\n\nclass GeocoderError extends Error {\n  code: string;\n\n  constructor() {\n    super('Geocoder service is not available for this device.');\n    this.code = 'E_NO_GEOCODER';\n  }\n}\n\n/**\n * Converts `GeolocationPosition` to JavaScript object.\n */\nfunction geolocationPositionToJSON(position: LocationObject): LocationObject {\n  const { coords, timestamp } = position;\n  return {\n    coords: {\n      latitude: coords.latitude,\n      longitude: coords.longitude,\n      altitude: coords.altitude,\n      accuracy: coords.accuracy,\n      altitudeAccuracy: coords.altitudeAccuracy,\n      heading: coords.heading,\n      speed: coords.speed,\n    },\n    timestamp,\n  };\n}\n\n/**\n * Checks whether given location didn't exceed given `maxAge` and fits in the required accuracy.\n */\nfunction isLocationValid(location: LocationObject, options: LocationLastKnownOptions): boolean {\n  const maxAge = typeof options.maxAge === 'number' ? options.maxAge : Infinity;\n  const requiredAccuracy =\n    typeof options.requiredAccuracy === 'number' ? options.requiredAccuracy : Infinity;\n  const locationAccuracy = location.coords.accuracy ?? Infinity;\n\n  return Date.now() - location.timestamp <= maxAge && locationAccuracy <= requiredAccuracy;\n}\n\n/**\n * Gets the permission details. The implementation is not very good as it's not\n * possible to query for permission on all browsers, apparently only the\n * latest versions will support this.\n */\nasync function getPermissionsAsync(shouldAsk = false): Promise<PermissionResponse> {\n  if (!navigator?.permissions?.query) {\n    throw new UnavailabilityError('expo-location', 'navigator.permissions API is not available');\n  }\n\n  const permission = await navigator.permissions.query({ name: 'geolocation' });\n\n  if (permission.state === 'granted') {\n    return {\n      status: PermissionStatus.GRANTED,\n      granted: true,\n      canAskAgain: true,\n      expires: 0,\n    };\n  }\n\n  if (permission.state === 'denied') {\n    return {\n      status: PermissionStatus.DENIED,\n      granted: false,\n      canAskAgain: true,\n      expires: 0,\n    };\n  }\n\n  if (shouldAsk) {\n    return new Promise((resolve) => {\n      navigator.geolocation.getCurrentPosition(\n        () => {\n          resolve({\n            status: PermissionStatus.GRANTED,\n            granted: true,\n            canAskAgain: true,\n            expires: 0,\n          });\n        },\n        (positionError: GeolocationPositionError) => {\n          if (positionError.code === positionError.PERMISSION_DENIED) {\n            resolve({\n              status: PermissionStatus.DENIED,\n              granted: false,\n              canAskAgain: true,\n              expires: 0,\n            });\n            return;\n          }\n\n          resolve({\n            status: PermissionStatus.GRANTED,\n            granted: false,\n            canAskAgain: true,\n            expires: 0,\n          });\n        }\n      );\n    });\n  }\n\n  // The permission state is 'prompt' when the permission has not been requested\n  // yet, tested on Chrome.\n  return {\n    status: PermissionStatus.UNDETERMINED,\n    granted: false,\n    canAskAgain: true,\n    expires: 0,\n  };\n}\n\nlet lastKnownPosition: LocationObject | null = null;\n\nexport default {\n  async getProviderStatusAsync(): Promise<{ locationServicesEnabled: boolean }> {\n    return {\n      locationServicesEnabled: 'geolocation' in navigator,\n    };\n  },\n  async getLastKnownPositionAsync(\n    options: LocationLastKnownOptions = {}\n  ): Promise<LocationObject | null> {\n    if (lastKnownPosition && isLocationValid(lastKnownPosition, options)) {\n      return lastKnownPosition;\n    }\n    return null;\n  },\n  async getCurrentPositionAsync(options: LocationOptions): Promise<LocationObject> {\n    return new Promise<LocationObject>((resolve, reject) => {\n      const resolver = (position) => {\n        lastKnownPosition = geolocationPositionToJSON(position);\n        resolve(lastKnownPosition);\n      };\n      navigator.geolocation.getCurrentPosition(resolver, reject, {\n        maximumAge: Infinity,\n        enableHighAccuracy: (options.accuracy ?? 0) > LocationAccuracy.Balanced,\n        ...options,\n      });\n    });\n  },\n  async removeWatchAsync(watchId): Promise<void> {\n    navigator.geolocation.clearWatch(watchId);\n  },\n  async watchDeviceHeading(headingId): Promise<void> {\n    console.warn('Location.watchDeviceHeading: is not supported on web');\n  },\n  async hasServicesEnabledAsync(): Promise<boolean> {\n    return 'geolocation' in navigator;\n  },\n  async geocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async reverseGeocodeAsync(): Promise<any[]> {\n    throw new GeocoderError();\n  },\n  async watchPositionImplAsync(watchId: string, options: LocationOptions): Promise<string> {\n    return new Promise<string>((resolve) => {\n      // @ts-ignore: the types here need to be fixed\n      watchId = global.navigator.geolocation.watchPosition(\n        (position) => {\n          lastKnownPosition = geolocationPositionToJSON(position);\n          LocationEventEmitter.emit('Expo.locationChanged', {\n            watchId,\n            location: lastKnownPosition,\n          });\n        },\n        undefined,\n        options\n      );\n      resolve(watchId);\n    });\n  },\n\n  async requestForegroundPermissionsAsync(): Promise<PermissionResponse> {\n    return getPermissionsAsync(true);\n  },\n  async requestBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n    return getPermissionsAsync(true);\n  },\n  async getForegroundPermissionsAsync(): Promise<PermissionResponse> {\n    return getPermissionsAsync();\n  },\n  async getBackgroundPermissionsAsync(): Promise<PermissionResponse> {\n    return getPermissionsAsync();\n  },\n};\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}