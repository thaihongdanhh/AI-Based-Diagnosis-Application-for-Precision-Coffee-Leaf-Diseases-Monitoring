{"ast":null,"code":"'use strict';\n\nimport * as ReactNativeFeatureFlags from \"../../src/private/featureflags/ReactNativeFeatureFlags\";\nimport { isPublicInstance as isFabricPublicInstance } from \"../ReactNative/ReactFabricPublicInstance/ReactFabricPublicInstanceUtils\";\nimport useRefEffect from \"../Utilities/useRefEffect\";\nimport { AnimatedEvent } from \"./AnimatedEvent\";\nimport NativeAnimatedHelper from \"../../src/private/animated/NativeAnimatedHelper\";\nimport AnimatedNode from \"./nodes/AnimatedNode\";\nimport AnimatedProps from \"./nodes/AnimatedProps\";\nimport AnimatedValue from \"./nodes/AnimatedValue\";\nimport { useCallback, useEffect, useLayoutEffect, useMemo, useReducer, useRef } from 'react';\nexport default function useAnimatedProps(props) {\n  const [, scheduleUpdate] = useReducer(count => count + 1, 0);\n  const onUpdateRef = useRef(null);\n  const timerRef = useRef(null);\n  const node = useMemo(() => new AnimatedProps(props, () => onUpdateRef.current?.()), [props]);\n  const useNativePropsInFabric = ReactNativeFeatureFlags.shouldUseSetNativePropsInFabric();\n  const useSetNativePropsInNativeAnimationsInFabric = ReactNativeFeatureFlags.shouldUseSetNativePropsInNativeAnimationsInFabric();\n  const useAnimatedPropsLifecycle = ReactNativeFeatureFlags.usePassiveEffectsForAnimations() ? useAnimatedPropsLifecycle_passiveEffects : useAnimatedPropsLifecycle_layoutEffects;\n  useAnimatedPropsLifecycle(node);\n  const refEffect = useCallback(instance => {\n    node.setNativeView(instance);\n    onUpdateRef.current = () => {\n      if (process.env.NODE_ENV === 'test') {\n        return scheduleUpdate();\n      }\n      const isFabricNode = isFabricInstance(instance);\n      if (node.__isNative) {\n        if (isFabricNode) {\n          if (useSetNativePropsInNativeAnimationsInFabric) {\n            instance.setNativeProps(node.__getAnimatedValue());\n          } else {\n            scheduleUpdate();\n          }\n        }\n        return;\n      }\n      if (typeof instance !== 'object' || typeof instance?.setNativeProps !== 'function') {\n        return scheduleUpdate();\n      }\n      if (!isFabricNode) {\n        return instance.setNativeProps(node.__getAnimatedValue());\n      }\n      if (!useNativePropsInFabric) {\n        return scheduleUpdate();\n      }\n      instance.setNativeProps(node.__getAnimatedValue());\n      if (timerRef.current != null) {\n        clearTimeout(timerRef.current);\n      }\n      timerRef.current = setTimeout(() => {\n        timerRef.current = null;\n        scheduleUpdate();\n      }, 48);\n    };\n    const target = getEventTarget(instance);\n    const events = [];\n    const animatedValueListeners = [];\n    for (const propName in props) {\n      const propValue = props[propName];\n      if (propValue instanceof AnimatedEvent && propValue.__isNative) {\n        propValue.__attach(target, propName);\n        events.push([propName, propValue]);\n        addListenersToPropsValue(propValue, animatedValueListeners);\n      }\n    }\n    return () => {\n      onUpdateRef.current = null;\n      for (const [propName, propValue] of events) {\n        propValue.__detach(target, propName);\n      }\n      for (const {\n        propValue,\n        listenerId\n      } of animatedValueListeners) {\n        propValue.removeListener(listenerId);\n      }\n    };\n  }, [node, useNativePropsInFabric, useSetNativePropsInNativeAnimationsInFabric, props]);\n  const callbackRef = useRefEffect(refEffect);\n  return [reduceAnimatedProps(node), callbackRef];\n}\nfunction reduceAnimatedProps(node) {\n  return Object.assign({}, node.__getValue(), {\n    collapsable: false\n  });\n}\nfunction addListenersToPropsValue(propValue, accumulator) {\n  if (propValue instanceof AnimatedValue) {\n    const listenerId = propValue.addListener(() => {});\n    accumulator.push({\n      propValue,\n      listenerId\n    });\n  } else if (Array.isArray(propValue)) {\n    for (const prop of propValue) {\n      addListenersToPropsValue(prop, accumulator);\n    }\n  } else if (propValue instanceof Object) {\n    addAnimatedValuesListenersToProps(propValue, accumulator);\n  }\n}\nfunction addAnimatedValuesListenersToProps(props, accumulator) {\n  for (const propName in props) {\n    const propValue = props[propName];\n    addListenersToPropsValue(propValue, accumulator);\n  }\n}\nfunction useAnimatedPropsLifecycle_layoutEffects(node) {\n  const prevNodeRef = useRef(null);\n  const isUnmountingRef = useRef(false);\n  useEffect(() => {\n    NativeAnimatedHelper.API.flushQueue();\n    let drivenAnimationEndedListener = null;\n    if (node.__isNative) {\n      drivenAnimationEndedListener = NativeAnimatedHelper.nativeEventEmitter.addListener('onUserDrivenAnimationEnded', data => {\n        node.update();\n      });\n    }\n    return () => {\n      drivenAnimationEndedListener?.remove();\n    };\n  });\n  useLayoutEffect(() => {\n    isUnmountingRef.current = false;\n    return () => {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n  useLayoutEffect(() => {\n    node.__attach();\n    if (prevNodeRef.current != null) {\n      const prevNode = prevNodeRef.current;\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return () => {\n      if (isUnmountingRef.current) {\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\nfunction useAnimatedPropsLifecycle_passiveEffects(node) {\n  const prevNodeRef = useRef(null);\n  const isUnmountingRef = useRef(false);\n  useEffect(() => {\n    NativeAnimatedHelper.API.flushQueue();\n  });\n  useEffect(() => {\n    isUnmountingRef.current = false;\n    return () => {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n  useEffect(() => {\n    node.__attach();\n    let drivenAnimationEndedListener = null;\n    if (node.__isNative) {\n      drivenAnimationEndedListener = NativeAnimatedHelper.nativeEventEmitter.addListener('onUserDrivenAnimationEnded', data => {\n        node.update();\n      });\n    }\n    if (prevNodeRef.current != null) {\n      const prevNode = prevNodeRef.current;\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return () => {\n      if (isUnmountingRef.current) {\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n      drivenAnimationEndedListener?.remove();\n    };\n  }, [node]);\n}\nfunction getEventTarget(instance) {\n  return typeof instance === 'object' && typeof instance?.getScrollableNode === 'function' ? instance.getScrollableNode() : instance;\n}\nfunction isFabricInstance(instance) {\n  return isFabricPublicInstance(instance) || isFabricPublicInstance(instance?.getNativeScrollRef?.()) || isFabricPublicInstance(instance?.getScrollResponder?.()?.getNativeScrollRef?.());\n}","map":{"version":3,"names":["ReactNativeFeatureFlags","isPublicInstance","isFabricPublicInstance","useRefEffect","AnimatedEvent","NativeAnimatedHelper","AnimatedNode","AnimatedProps","AnimatedValue","useCallback","useEffect","useLayoutEffect","useMemo","useReducer","useRef","useAnimatedProps","props","scheduleUpdate","count","onUpdateRef","timerRef","node","current","useNativePropsInFabric","shouldUseSetNativePropsInFabric","useSetNativePropsInNativeAnimationsInFabric","shouldUseSetNativePropsInNativeAnimationsInFabric","useAnimatedPropsLifecycle","usePassiveEffectsForAnimations","useAnimatedPropsLifecycle_passiveEffects","useAnimatedPropsLifecycle_layoutEffects","refEffect","instance","setNativeView","process","env","NODE_ENV","isFabricNode","isFabricInstance","__isNative","setNativeProps","__getAnimatedValue","clearTimeout","setTimeout","target","getEventTarget","events","animatedValueListeners","propName","propValue","__attach","push","addListenersToPropsValue","__detach","listenerId","removeListener","callbackRef","reduceAnimatedProps","Object","assign","__getValue","collapsable","accumulator","addListener","Array","isArray","prop","addAnimatedValuesListenersToProps","prevNodeRef","isUnmountingRef","API","flushQueue","drivenAnimationEndedListener","nativeEventEmitter","data","update","remove","prevNode","__restoreDefaultValues","getScrollableNode","getNativeScrollRef","getScrollResponder"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/react-native/Libraries/Animated/useAnimatedProps.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict-local\n * @format\n */\n\n'use strict';\n\nimport type {EventSubscription} from '../EventEmitter/NativeEventEmitter';\n\nimport * as ReactNativeFeatureFlags from '../../src/private/featureflags/ReactNativeFeatureFlags';\nimport {isPublicInstance as isFabricPublicInstance} from '../ReactNative/ReactFabricPublicInstance/ReactFabricPublicInstanceUtils';\nimport useRefEffect from '../Utilities/useRefEffect';\nimport {AnimatedEvent} from './AnimatedEvent';\nimport NativeAnimatedHelper from '../../src/private/animated/NativeAnimatedHelper';\nimport AnimatedNode from './nodes/AnimatedNode';\nimport AnimatedProps from './nodes/AnimatedProps';\nimport AnimatedValue from './nodes/AnimatedValue';\nimport {\n  useCallback,\n  useEffect,\n  useLayoutEffect,\n  useMemo,\n  useReducer,\n  useRef,\n} from 'react';\n\ntype ReducedProps<TProps> = {\n  ...TProps,\n  collapsable: boolean,\n  ...\n};\ntype CallbackRef<T> = T => mixed;\n\ntype AnimatedValueListeners = Array<{\n  propValue: AnimatedValue,\n  listenerId: string,\n}>;\n\nexport default function useAnimatedProps<TProps: {...}, TInstance>(\n  props: TProps,\n): [ReducedProps<TProps>, CallbackRef<TInstance | null>] {\n  const [, scheduleUpdate] = useReducer<number, void>(count => count + 1, 0);\n  const onUpdateRef = useRef<?() => void>(null);\n  const timerRef = useRef<TimeoutID | null>(null);\n\n  // TODO: Only invalidate `node` if animated props or `style` change. In the\n  // previous implementation, we permitted `style` to override props with the\n  // same name property name as styles, so we can probably continue doing that.\n  // The ordering of other props *should* not matter.\n  const node = useMemo(\n    () => new AnimatedProps(props, () => onUpdateRef.current?.()),\n    [props],\n  );\n  const useNativePropsInFabric =\n    ReactNativeFeatureFlags.shouldUseSetNativePropsInFabric();\n  const useSetNativePropsInNativeAnimationsInFabric =\n    ReactNativeFeatureFlags.shouldUseSetNativePropsInNativeAnimationsInFabric();\n\n  const useAnimatedPropsLifecycle =\n    ReactNativeFeatureFlags.usePassiveEffectsForAnimations()\n      ? useAnimatedPropsLifecycle_passiveEffects\n      : useAnimatedPropsLifecycle_layoutEffects;\n\n  useAnimatedPropsLifecycle(node);\n\n  // TODO: This \"effect\" does three things:\n  //\n  //   1) Call `setNativeView`.\n  //   2) Update `onUpdateRef`.\n  //   3) Update listeners for `AnimatedEvent` props.\n  //\n  // Ideally, each of these would be separate \"effects\" so that they are not\n  // unnecessarily re-run when irrelevant dependencies change. For example, we\n  // should be able to hoist all `AnimatedEvent` props and only do #3 if either\n  // the `AnimatedEvent` props change or `instance` changes.\n  //\n  // But there is no way to transparently compose three separate callback refs,\n  // so we just combine them all into one for now.\n  const refEffect = useCallback(\n    (instance: TInstance) => {\n      // NOTE: This may be called more often than necessary (e.g. when `props`\n      // changes), but `setNativeView` already optimizes for that.\n      node.setNativeView(instance);\n\n      // NOTE: When using the JS animation driver, this callback is called on\n      // every animation frame. When using the native driver, this callback is\n      // called when the animation completes.\n      onUpdateRef.current = () => {\n        if (process.env.NODE_ENV === 'test') {\n          // Check 1: this is a test.\n          // call `scheduleUpdate` to bypass use of setNativeProps.\n          return scheduleUpdate();\n        }\n\n        const isFabricNode = isFabricInstance(instance);\n        if (node.__isNative) {\n          // Check 2: this is an animation driven by native.\n          // In native driven animations, this callback is only called once the animation completes.\n          if (isFabricNode) {\n            // Call `scheduleUpdate` to synchronise Fiber and Shadow tree.\n            // Must not be called in Paper.\n            if (useSetNativePropsInNativeAnimationsInFabric) {\n              // $FlowFixMe[incompatible-use]\n              instance.setNativeProps(node.__getAnimatedValue());\n            } else {\n              scheduleUpdate();\n            }\n          }\n          return;\n        }\n\n        if (\n          typeof instance !== 'object' ||\n          typeof instance?.setNativeProps !== 'function'\n        ) {\n          // Check 3: the instance does not support setNativeProps. Call `scheduleUpdate`.\n          return scheduleUpdate();\n        }\n\n        if (!isFabricNode) {\n          // Check 4: this is a paper instance, call setNativeProps.\n          // $FlowIgnore[not-a-function] - Assume it's still a function.\n          // $FlowFixMe[incompatible-use]\n          return instance.setNativeProps(node.__getAnimatedValue());\n        }\n\n        if (!useNativePropsInFabric) {\n          // Check 5: setNativeProps are disabled.\n          return scheduleUpdate();\n        }\n\n        // This is a Fabric instance and setNativeProps is supported.\n\n        // $FlowIgnore[not-a-function] - Assume it's still a function.\n        // $FlowFixMe[incompatible-use]\n        instance.setNativeProps(node.__getAnimatedValue());\n\n        // Keeping state of Fiber tree and Shadow tree in sync.\n        //\n        // This is done by calling `scheduleUpdate` which will trigger a commit.\n        // However, React commit is not fast enough to drive animations.\n        // This is where setNativeProps comes in handy but the state between\n        // Fiber tree and Shadow tree needs to be kept in sync.\n        // The goal is to call `scheduleUpdate` as little as possible to maintain\n        // performance but frequently enough to keep state in sync.\n        // Debounce is set to 48ms, which is 3 * the duration of a frame.\n        // 3 frames was the highest value where flickering state was not observed.\n        if (timerRef.current != null) {\n          clearTimeout(timerRef.current);\n        }\n        timerRef.current = setTimeout(() => {\n          timerRef.current = null;\n          scheduleUpdate();\n        }, 48);\n      };\n\n      const target = getEventTarget(instance);\n      const events = [];\n      const animatedValueListeners: AnimatedValueListeners = [];\n\n      for (const propName in props) {\n        // $FlowFixMe[invalid-computed-prop]\n        const propValue = props[propName];\n        if (propValue instanceof AnimatedEvent && propValue.__isNative) {\n          propValue.__attach(target, propName);\n          events.push([propName, propValue]);\n          // $FlowFixMe[incompatible-call] - the `addListenersToPropsValue` drills down the propValue.\n          addListenersToPropsValue(propValue, animatedValueListeners);\n        }\n      }\n\n      return () => {\n        onUpdateRef.current = null;\n\n        for (const [propName, propValue] of events) {\n          propValue.__detach(target, propName);\n        }\n\n        for (const {propValue, listenerId} of animatedValueListeners) {\n          propValue.removeListener(listenerId);\n        }\n      };\n    },\n    [\n      node,\n      useNativePropsInFabric,\n      useSetNativePropsInNativeAnimationsInFabric,\n      props,\n    ],\n  );\n  const callbackRef = useRefEffect<TInstance>(refEffect);\n\n  return [reduceAnimatedProps<TProps>(node), callbackRef];\n}\n\nfunction reduceAnimatedProps<TProps>(node: AnimatedNode): ReducedProps<TProps> {\n  // Force `collapsable` to be false so that the native view is not flattened.\n  // Flattened views cannot be accurately referenced by the native driver.\n  return {\n    ...node.__getValue(),\n    collapsable: false,\n  };\n}\n\nfunction addListenersToPropsValue(\n  propValue: AnimatedValue,\n  accumulator: AnimatedValueListeners,\n) {\n  // propValue can be a scalar value, an array or an object.\n  if (propValue instanceof AnimatedValue) {\n    const listenerId = propValue.addListener(() => {});\n    accumulator.push({propValue, listenerId});\n  } else if (Array.isArray(propValue)) {\n    // An array can be an array of scalar values, arrays of arrays, or arrays of objects\n    for (const prop of propValue) {\n      addListenersToPropsValue(prop, accumulator);\n    }\n  } else if (propValue instanceof Object) {\n    addAnimatedValuesListenersToProps(propValue, accumulator);\n  }\n}\n\nfunction addAnimatedValuesListenersToProps(\n  props: AnimatedNode,\n  accumulator: AnimatedValueListeners,\n) {\n  for (const propName in props) {\n    // $FlowFixMe[prop-missing] - This is an object contained in a prop, but we don't know the exact type.\n    const propValue = props[propName];\n    addListenersToPropsValue(propValue, accumulator);\n  }\n}\n\n/**\n * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`\n * and `__detach`. However, this is more complicated because `AnimatedProps`\n * uses reference counting to determine when to recursively detach its children\n * nodes. So in order to optimize this, we avoid detaching until the next attach\n * unless we are unmounting.\n */\nfunction useAnimatedPropsLifecycle_layoutEffects(node: AnimatedProps): void {\n  const prevNodeRef = useRef<?AnimatedProps>(null);\n  const isUnmountingRef = useRef<boolean>(false);\n\n  useEffect(() => {\n    // It is ok for multiple components to call `flushQueue` because it noops\n    // if the queue is empty. When multiple animated components are mounted at\n    // the same time. Only first component flushes the queue and the others will noop.\n    NativeAnimatedHelper.API.flushQueue();\n    let drivenAnimationEndedListener: ?EventSubscription = null;\n    if (node.__isNative) {\n      drivenAnimationEndedListener =\n        NativeAnimatedHelper.nativeEventEmitter.addListener(\n          'onUserDrivenAnimationEnded',\n          data => {\n            node.update();\n          },\n        );\n    }\n\n    return () => {\n      drivenAnimationEndedListener?.remove();\n    };\n  });\n\n  useLayoutEffect(() => {\n    isUnmountingRef.current = false;\n    return () => {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n\n  useLayoutEffect(() => {\n    node.__attach();\n    if (prevNodeRef.current != null) {\n      const prevNode = prevNodeRef.current;\n      // TODO: Stop restoring default values (unless `reset` is called).\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return () => {\n      if (isUnmountingRef.current) {\n        // NOTE: Do not restore default values on unmount, see D18197735.\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n    };\n  }, [node]);\n}\n\n/**\n * Manages the lifecycle of the supplied `AnimatedProps` by invoking `__attach`\n * and `__detach`. However, this is more complicated because `AnimatedProps`\n * uses reference counting to determine when to recursively detach its children\n * nodes. So in order to optimize this, we avoid detaching until the next attach\n * unless we are unmounting.\n *\n * NOTE: unlike `useAnimatedPropsLifecycle_layoutEffects`, this version uses passive effects to setup animation graph.\n */\nfunction useAnimatedPropsLifecycle_passiveEffects(node: AnimatedProps): void {\n  const prevNodeRef = useRef<?AnimatedProps>(null);\n  const isUnmountingRef = useRef<boolean>(false);\n\n  useEffect(() => {\n    // It is ok for multiple components to call `flushQueue` because it noops\n    // if the queue is empty. When multiple animated components are mounted at\n    // the same time. Only first component flushes the queue and the others will noop.\n    NativeAnimatedHelper.API.flushQueue();\n  });\n\n  useEffect(() => {\n    isUnmountingRef.current = false;\n    return () => {\n      isUnmountingRef.current = true;\n    };\n  }, []);\n\n  useEffect(() => {\n    node.__attach();\n    let drivenAnimationEndedListener: ?EventSubscription = null;\n\n    if (node.__isNative) {\n      drivenAnimationEndedListener =\n        NativeAnimatedHelper.nativeEventEmitter.addListener(\n          'onUserDrivenAnimationEnded',\n          data => {\n            node.update();\n          },\n        );\n    }\n    if (prevNodeRef.current != null) {\n      const prevNode = prevNodeRef.current;\n      // TODO: Stop restoring default values (unless `reset` is called).\n      prevNode.__restoreDefaultValues();\n      prevNode.__detach();\n      prevNodeRef.current = null;\n    }\n    return () => {\n      if (isUnmountingRef.current) {\n        // NOTE: Do not restore default values on unmount, see D18197735.\n        node.__detach();\n      } else {\n        prevNodeRef.current = node;\n      }\n\n      drivenAnimationEndedListener?.remove();\n    };\n  }, [node]);\n}\n\nfunction getEventTarget<TInstance>(instance: TInstance): TInstance {\n  return typeof instance === 'object' &&\n    typeof instance?.getScrollableNode === 'function'\n    ? // $FlowFixMe[incompatible-use] - Legacy instance assumptions.\n      instance.getScrollableNode()\n    : instance;\n}\n\n// $FlowFixMe[unclear-type] - Legacy instance assumptions.\nfunction isFabricInstance(instance: any): boolean {\n  return (\n    isFabricPublicInstance(instance) ||\n    // Some components have a setNativeProps function but aren't a host component\n    // such as lists like FlatList and SectionList. These should also use\n    // forceUpdate in Fabric since setNativeProps doesn't exist on the underlying\n    // host component. This crazy hack is essentially special casing those lists and\n    // ScrollView itself to use forceUpdate in Fabric.\n    // If these components end up using forwardRef then these hacks can go away\n    // as instance would actually be the underlying host component and the above check\n    // would be sufficient.\n    isFabricPublicInstance(instance?.getNativeScrollRef?.()) ||\n    isFabricPublicInstance(\n      instance?.getScrollResponder?.()?.getNativeScrollRef?.(),\n    )\n  );\n}\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}