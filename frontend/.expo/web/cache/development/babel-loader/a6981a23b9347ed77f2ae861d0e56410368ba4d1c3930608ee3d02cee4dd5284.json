{"ast":null,"code":"'use strict';\n\nimport processColor from \"./processColor\";\nexport default function processFilter(filter) {\n  let result = [];\n  if (filter == null) {\n    return result;\n  }\n  if (typeof filter === 'string') {\n    filter = filter.replace(/\\n/g, ' ');\n    const regex = /([\\w-]+)\\(([^()]*|\\([^()]*\\)|[^()]*\\([^()]*\\)[^()]*)\\)/g;\n    let matches;\n    while (matches = regex.exec(filter)) {\n      let filterName = matches[1].toLowerCase();\n      if (filterName === 'drop-shadow') {\n        const dropShadow = parseDropShadow(matches[2]);\n        if (dropShadow != null) {\n          result.push({\n            dropShadow\n          });\n        } else {\n          return [];\n        }\n      } else {\n        const camelizedName = filterName === 'drop-shadow' ? 'dropShadow' : filterName === 'hue-rotate' ? 'hueRotate' : filterName;\n        const amount = _getFilterAmount(camelizedName, matches[2]);\n        if (amount != null) {\n          const filterFunction = {};\n          filterFunction[camelizedName] = amount;\n          result.push(filterFunction);\n        } else {\n          return [];\n        }\n      }\n    }\n  } else if (Array.isArray(filter)) {\n    for (const filterFunction of filter) {\n      const [filterName, filterValue] = Object.entries(filterFunction)[0];\n      if (filterName === 'dropShadow') {\n        const dropShadow = parseDropShadow(filterValue);\n        if (dropShadow == null) {\n          return [];\n        }\n        result.push({\n          dropShadow\n        });\n      } else {\n        const amount = _getFilterAmount(filterName, filterValue);\n        if (amount != null) {\n          const resultObject = {};\n          resultObject[filterName] = amount;\n          result.push(resultObject);\n        } else {\n          return [];\n        }\n      }\n    }\n  } else {\n    throw new TypeError(`${typeof filter} filter is not a string or array`);\n  }\n  return result;\n}\nfunction _getFilterAmount(filterName, filterArgs) {\n  let filterArgAsNumber;\n  let unit;\n  if (typeof filterArgs === 'string') {\n    const argsWithUnitsRegex = new RegExp(/([+-]?\\d*(\\.\\d+)?)([a-zA-Z%]+)?/g);\n    const match = argsWithUnitsRegex.exec(filterArgs);\n    if (!match || isNaN(Number(match[1]))) {\n      return undefined;\n    }\n    filterArgAsNumber = Number(match[1]);\n    unit = match[3];\n  } else if (typeof filterArgs === 'number') {\n    filterArgAsNumber = filterArgs;\n  } else {\n    return undefined;\n  }\n  switch (filterName) {\n    case 'hueRotate':\n      if (filterArgAsNumber === 0) {\n        return 0;\n      }\n      if (unit !== 'deg' && unit !== 'rad') {\n        return undefined;\n      }\n      return unit === 'rad' ? 180 * filterArgAsNumber / Math.PI : filterArgAsNumber;\n    case 'blur':\n      if (unit && unit !== 'px' || filterArgAsNumber < 0) {\n        return undefined;\n      }\n      return filterArgAsNumber;\n    case 'brightness':\n    case 'contrast':\n    case 'grayscale':\n    case 'invert':\n    case 'opacity':\n    case 'saturate':\n    case 'sepia':\n      if (unit && unit !== '%' && unit !== 'px' || filterArgAsNumber < 0) {\n        return undefined;\n      }\n      if (unit === '%') {\n        filterArgAsNumber /= 100;\n      }\n      return filterArgAsNumber;\n    default:\n      return undefined;\n  }\n}\nfunction parseDropShadow(rawDropShadow) {\n  const dropShadow = typeof rawDropShadow === 'string' ? parseDropShadowString(rawDropShadow) : rawDropShadow;\n  const parsedDropShadow = {\n    offsetX: 0,\n    offsetY: 0\n  };\n  let offsetX;\n  let offsetY;\n  for (const arg in dropShadow) {\n    let value;\n    switch (arg) {\n      case 'offsetX':\n        value = typeof dropShadow.offsetX === 'string' ? parseLength(dropShadow.offsetX) : dropShadow.offsetX;\n        if (value == null) {\n          return null;\n        }\n        offsetX = value;\n        break;\n      case 'offsetY':\n        value = typeof dropShadow.offsetY === 'string' ? parseLength(dropShadow.offsetY) : dropShadow.offsetY;\n        if (value == null) {\n          return null;\n        }\n        offsetY = value;\n        break;\n      case 'standardDeviation':\n        value = typeof dropShadow.standardDeviation === 'string' ? parseLength(dropShadow.standardDeviation) : dropShadow.standardDeviation;\n        if (value == null || value < 0) {\n          return null;\n        }\n        parsedDropShadow.standardDeviation = value;\n        break;\n      case 'color':\n        const color = processColor(dropShadow.color);\n        if (color == null) {\n          return null;\n        }\n        parsedDropShadow.color = color;\n        break;\n      default:\n        return null;\n    }\n  }\n  if (offsetX == null || offsetY == null) {\n    return null;\n  }\n  parsedDropShadow.offsetX = offsetX;\n  parsedDropShadow.offsetY = offsetY;\n  return parsedDropShadow;\n}\nfunction parseDropShadowString(rawDropShadow) {\n  const dropShadow = {\n    offsetX: 0,\n    offsetY: 0\n  };\n  let offsetX;\n  let offsetY;\n  let lengthCount = 0;\n  let keywordDetectedAfterLength = false;\n  for (const arg of rawDropShadow.split(/\\s+(?![^(]*\\))/)) {\n    const processedColor = processColor(arg);\n    if (processedColor != null) {\n      if (dropShadow.color != null) {\n        return null;\n      }\n      if (offsetX != null) {\n        keywordDetectedAfterLength = true;\n      }\n      dropShadow.color = arg;\n      continue;\n    }\n    switch (lengthCount) {\n      case 0:\n        offsetX = arg;\n        lengthCount++;\n        break;\n      case 1:\n        if (keywordDetectedAfterLength) {\n          return null;\n        }\n        offsetY = arg;\n        lengthCount++;\n        break;\n      case 2:\n        if (keywordDetectedAfterLength) {\n          return null;\n        }\n        dropShadow.standardDeviation = arg;\n        lengthCount++;\n        break;\n      default:\n        return null;\n    }\n  }\n  if (offsetX == null || offsetY == null) {\n    return null;\n  }\n  dropShadow.offsetX = offsetX;\n  dropShadow.offsetY = offsetY;\n  return dropShadow;\n}\nfunction parseLength(length) {\n  const argsWithUnitsRegex = /([+-]?\\d*(\\.\\d+)?)([\\w\\W]+)?/g;\n  const match = argsWithUnitsRegex.exec(length);\n  if (!match || Number.isNaN(match[1])) {\n    return null;\n  }\n  if (match[3] != null && match[3] !== 'px') {\n    return null;\n  }\n  return Number(match[1]);\n}","map":{"version":3,"names":["processColor","processFilter","filter","result","replace","regex","matches","exec","filterName","toLowerCase","dropShadow","parseDropShadow","push","camelizedName","amount","_getFilterAmount","filterFunction","Array","isArray","filterValue","Object","entries","resultObject","TypeError","filterArgs","filterArgAsNumber","unit","argsWithUnitsRegex","RegExp","match","isNaN","Number","undefined","Math","PI","rawDropShadow","parseDropShadowString","parsedDropShadow","offsetX","offsetY","arg","value","parseLength","standardDeviation","color","lengthCount","keywordDetectedAfterLength","split","processedColor","length"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/react-native/Libraries/StyleSheet/processFilter.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format strict-local\n * @flow\n * @oncall react-native\n */\n\n'use strict';\n\nimport type {ColorValue} from './StyleSheet';\nimport type {DropShadowValue, FilterFunction} from './StyleSheetTypes';\n\nimport processColor from './processColor';\n\ntype ParsedFilter =\n  | {brightness: number}\n  | {blur: number}\n  | {contrast: number}\n  | {grayscale: number}\n  | {hueRotate: number}\n  | {invert: number}\n  | {opacity: number}\n  | {saturate: number}\n  | {sepia: number}\n  | {dropShadow: ParsedDropShadow};\n\ntype ParsedDropShadow = {\n  offsetX: number,\n  offsetY: number,\n  standardDeviation?: number,\n  color?: ColorValue,\n};\n\nexport default function processFilter(\n  filter: ?($ReadOnlyArray<FilterFunction> | string),\n): $ReadOnlyArray<ParsedFilter> {\n  let result: Array<ParsedFilter> = [];\n  if (filter == null) {\n    return result;\n  }\n\n  if (typeof filter === 'string') {\n    filter = filter.replace(/\\n/g, ' ');\n\n    // matches on functions with args and nested functions like \"drop-shadow(10 10 10 rgba(0, 0, 0, 1))\"\n    const regex = /([\\w-]+)\\(([^()]*|\\([^()]*\\)|[^()]*\\([^()]*\\)[^()]*)\\)/g;\n    let matches;\n\n    while ((matches = regex.exec(filter))) {\n      let filterName = matches[1].toLowerCase();\n      if (filterName === 'drop-shadow') {\n        const dropShadow = parseDropShadow(matches[2]);\n        if (dropShadow != null) {\n          result.push({dropShadow});\n        } else {\n          return [];\n        }\n      } else {\n        const camelizedName =\n          filterName === 'drop-shadow'\n            ? 'dropShadow'\n            : filterName === 'hue-rotate'\n              ? 'hueRotate'\n              : filterName;\n        const amount = _getFilterAmount(camelizedName, matches[2]);\n\n        if (amount != null) {\n          const filterFunction = {};\n          // $FlowFixMe The key will be the correct one but flow can't see that.\n          filterFunction[camelizedName] = amount;\n          // $FlowFixMe The key will be the correct one but flow can't see that.\n          result.push(filterFunction);\n        } else {\n          // If any primitive is invalid then apply none of the filters. This is how\n          // web works and makes it clear that something is wrong becuase no\n          // graphical effects are happening.\n          return [];\n        }\n      }\n    }\n  } else if (Array.isArray(filter)) {\n    for (const filterFunction of filter) {\n      const [filterName, filterValue] = Object.entries(filterFunction)[0];\n      if (filterName === 'dropShadow') {\n        // $FlowFixMe\n        const dropShadow = parseDropShadow(filterValue);\n        if (dropShadow == null) {\n          return [];\n        }\n        result.push({dropShadow});\n      } else {\n        const amount = _getFilterAmount(filterName, filterValue);\n\n        if (amount != null) {\n          const resultObject = {};\n          // $FlowFixMe\n          resultObject[filterName] = amount;\n          // $FlowFixMe\n          result.push(resultObject);\n        } else {\n          // If any primitive is invalid then apply none of the filters. This is how\n          // web works and makes it clear that something is wrong becuase no\n          // graphical effects are happening.\n          return [];\n        }\n      }\n    }\n  } else {\n    throw new TypeError(`${typeof filter} filter is not a string or array`);\n  }\n\n  return result;\n}\n\nfunction _getFilterAmount(filterName: string, filterArgs: mixed): ?number {\n  let filterArgAsNumber: number;\n  let unit: string;\n  if (typeof filterArgs === 'string') {\n    // matches on args with units like \"1.5 5% -80deg\"\n    const argsWithUnitsRegex = new RegExp(/([+-]?\\d*(\\.\\d+)?)([a-zA-Z%]+)?/g);\n    const match = argsWithUnitsRegex.exec(filterArgs);\n\n    if (!match || isNaN(Number(match[1]))) {\n      return undefined;\n    }\n\n    filterArgAsNumber = Number(match[1]);\n    unit = match[3];\n  } else if (typeof filterArgs === 'number') {\n    filterArgAsNumber = filterArgs;\n  } else {\n    return undefined;\n  }\n\n  switch (filterName) {\n    // Hue rotate takes some angle that can have a unit and can be\n    // negative. Additionally, 0 with no unit is allowed.\n    case 'hueRotate':\n      if (filterArgAsNumber === 0) {\n        return 0;\n      }\n      if (unit !== 'deg' && unit !== 'rad') {\n        return undefined;\n      }\n      return unit === 'rad'\n        ? (180 * filterArgAsNumber) / Math.PI\n        : filterArgAsNumber;\n    // blur takes any positive CSS length that is not a percent. In RN\n    // we currently only have DIPs, so we are not parsing units here.\n    case 'blur':\n      if ((unit && unit !== 'px') || filterArgAsNumber < 0) {\n        return undefined;\n      }\n      return filterArgAsNumber;\n    // All other filters except take a non negative number or percentage. There\n    // are no units associated with this value and percentage numbers map 1-to-1\n    // to a non-percentage number (e.g. 50% == 0.5).\n    case 'brightness':\n    case 'contrast':\n    case 'grayscale':\n    case 'invert':\n    case 'opacity':\n    case 'saturate':\n    case 'sepia':\n      if ((unit && unit !== '%' && unit !== 'px') || filterArgAsNumber < 0) {\n        return undefined;\n      }\n      if (unit === '%') {\n        filterArgAsNumber /= 100;\n      }\n      return filterArgAsNumber;\n    default:\n      return undefined;\n  }\n}\n\nfunction parseDropShadow(\n  rawDropShadow: string | DropShadowValue,\n): ?ParsedDropShadow {\n  const dropShadow =\n    typeof rawDropShadow === 'string'\n      ? parseDropShadowString(rawDropShadow)\n      : rawDropShadow;\n\n  const parsedDropShadow: ParsedDropShadow = {\n    offsetX: 0,\n    offsetY: 0,\n  };\n  let offsetX: number;\n  let offsetY: number;\n\n  for (const arg in dropShadow) {\n    let value;\n    switch (arg) {\n      case 'offsetX':\n        value =\n          typeof dropShadow.offsetX === 'string'\n            ? parseLength(dropShadow.offsetX)\n            : dropShadow.offsetX;\n        if (value == null) {\n          return null;\n        }\n        offsetX = value;\n        break;\n      case 'offsetY':\n        value =\n          typeof dropShadow.offsetY === 'string'\n            ? parseLength(dropShadow.offsetY)\n            : dropShadow.offsetY;\n        if (value == null) {\n          return null;\n        }\n        offsetY = value;\n        break;\n      case 'standardDeviation':\n        value =\n          typeof dropShadow.standardDeviation === 'string'\n            ? parseLength(dropShadow.standardDeviation)\n            : dropShadow.standardDeviation;\n        if (value == null || value < 0) {\n          return null;\n        }\n        parsedDropShadow.standardDeviation = value;\n        break;\n      case 'color':\n        const color = processColor(dropShadow.color);\n        if (color == null) {\n          return null;\n        }\n        parsedDropShadow.color = color;\n        break;\n      default:\n        return null;\n    }\n  }\n\n  if (offsetX == null || offsetY == null) {\n    return null;\n  }\n\n  parsedDropShadow.offsetX = offsetX;\n  parsedDropShadow.offsetY = offsetY;\n\n  return parsedDropShadow;\n}\n\nfunction parseDropShadowString(rawDropShadow: string): ?DropShadowValue {\n  const dropShadow: DropShadowValue = {\n    offsetX: 0,\n    offsetY: 0,\n  };\n  let offsetX: string;\n  let offsetY: string;\n  let lengthCount = 0;\n  let keywordDetectedAfterLength = false;\n\n  // split args by all whitespaces that are not in parenthesis\n  for (const arg of rawDropShadow.split(/\\s+(?![^(]*\\))/)) {\n    const processedColor = processColor(arg);\n    if (processedColor != null) {\n      if (dropShadow.color != null) {\n        return null;\n      }\n      if (offsetX != null) {\n        keywordDetectedAfterLength = true;\n      }\n      dropShadow.color = arg;\n      continue;\n    }\n\n    switch (lengthCount) {\n      case 0:\n        offsetX = arg;\n        lengthCount++;\n        break;\n      case 1:\n        if (keywordDetectedAfterLength) {\n          return null;\n        }\n        offsetY = arg;\n        lengthCount++;\n        break;\n      case 2:\n        if (keywordDetectedAfterLength) {\n          return null;\n        }\n        dropShadow.standardDeviation = arg;\n        lengthCount++;\n        break;\n      default:\n        return null;\n    }\n  }\n  if (offsetX == null || offsetY == null) {\n    return null;\n  }\n\n  dropShadow.offsetX = offsetX;\n  dropShadow.offsetY = offsetY;\n  return dropShadow;\n}\n\nfunction parseLength(length: string): ?number {\n  // matches on args with units like \"1.5 5% -80deg\"\n  const argsWithUnitsRegex = /([+-]?\\d*(\\.\\d+)?)([\\w\\W]+)?/g;\n  const match = argsWithUnitsRegex.exec(length);\n\n  if (!match || Number.isNaN(match[1])) {\n    return null;\n  }\n\n  if (match[3] != null && match[3] !== 'px') {\n    return null;\n  }\n\n  return Number(match[1]);\n}\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}