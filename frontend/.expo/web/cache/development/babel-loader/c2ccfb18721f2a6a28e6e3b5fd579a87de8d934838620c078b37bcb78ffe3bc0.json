{"ast":null,"code":"import invariant from 'invariant';\nimport * as CapabilityUtils from \"./WebCapabilityUtils\";\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from \"./WebConstants\";\nimport { requestUserMediaAsync } from \"./WebUserMediaManager\";\nexport function getImageSize(videoWidth, videoHeight, scale) {\n  const width = videoWidth * scale;\n  const ratio = videoWidth / width;\n  const height = videoHeight / ratio;\n  return {\n    width,\n    height\n  };\n}\nexport function toDataURL(canvas, imageType, quality) {\n  const types = ['png', 'jpg'];\n  invariant(types.includes(imageType), `expo-camera: ${imageType} is not a valid ImageType. Expected a string from: ${types.join(', ')}`);\n  const format = ImageTypeFormat[imageType];\n  if (imageType === 'jpg') {\n    invariant(quality <= 1 && quality >= 0, `expo-camera: ${quality} is not a valid image quality. Expected a number from 0...1`);\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\nexport function hasValidConstraints(preferredCameraType, width, height) {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\nfunction ensureCameraPictureOptions(config) {\n  const captureOptions = {\n    scale: 1,\n    imageType: 'png',\n    isImageMirror: false\n  };\n  for (const key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n  return captureOptions;\n}\nconst DEFAULT_QUALITY = 0.92;\nexport function captureImageData(video, pictureOptions = {}) {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  const canvas = captureImageContext(video, pictureOptions);\n  const context = canvas.getContext('2d', {\n    alpha: false\n  });\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\nexport function captureImageContext(video, {\n  scale = 1,\n  isImageMirror = false\n}) {\n  const {\n    videoWidth,\n    videoHeight\n  } = video;\n  const {\n    width,\n    height\n  } = getImageSize(videoWidth, videoHeight, scale);\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d', {\n    alpha: false\n  });\n  if (!context) {\n    throw new Error('Context is not defined');\n  }\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n  context.drawImage(video, 0, 0, width, height);\n  return canvas;\n}\nexport function captureImage(video, pictureOptions) {\n  const config = ensureCameraPictureOptions(pictureOptions);\n  const canvas = captureImageContext(video, config);\n  const {\n    imageType,\n    quality = DEFAULT_QUALITY\n  } = config;\n  return toDataURL(canvas, imageType, quality);\n}\nfunction getSupportedConstraints() {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n  return null;\n}\nexport function getIdealConstraints(preferredCameraType, width, height) {\n  const preferredConstraints = {\n    audio: false,\n    video: {}\n  };\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n  const supports = getSupportedConstraints();\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n  const types = ['front', 'back'];\n  if (preferredCameraType && types.includes(preferredCameraType)) {\n    const facingMode = CameraTypeToFacingMode[preferredCameraType];\n    if (isWebKit()) {\n      const key = facingMode === 'user' ? 'exact' : 'ideal';\n      preferredConstraints.video.facingMode = {\n        [key]: facingMode\n      };\n    } else {\n      preferredConstraints.video.facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType]\n      };\n    }\n  }\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n  return preferredConstraints;\n}\nfunction isMediaTrackConstraints(input) {\n  return input && typeof input.video !== 'boolean';\n}\nexport async function getPreferredStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {\n  try {\n    return await getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);\n  } catch (error) {\n    if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {\n      const nextCameraType = preferredCameraType === 'back' ? 'front' : 'back';\n      return await getStreamDevice(nextCameraType, preferredWidth, preferredHeight);\n    }\n    throw error;\n  }\n}\nexport async function getStreamDevice(preferredCameraType, preferredWidth, preferredHeight) {\n  const constraints = getIdealConstraints(preferredCameraType, preferredWidth, preferredHeight);\n  const stream = await requestUserMediaAsync(constraints);\n  return stream;\n}\nexport function isWebKit() {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\nexport function compareStreams(a, b) {\n  if (!a || !b) {\n    return false;\n  }\n  const settingsA = a.getTracks()[0].getSettings();\n  const settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\nexport function capture(video, settings, config) {\n  const base64 = captureImage(video, config);\n  const capturedPicture = {\n    uri: base64,\n    base64,\n    width: 0,\n    height: 0\n  };\n  if (settings) {\n    const {\n      width = 0,\n      height = 0\n    } = settings;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n  return capturedPicture;\n}\nexport async function syncTrackCapabilities(cameraType, stream, settings = {}) {\n  if (stream?.getVideoTracks) {\n    await Promise.all(stream.getVideoTracks().map(track => onCapabilitiesReady(cameraType, track, settings)));\n  }\n}\nasync function onCapabilitiesReady(cameraType, track, settings = {}) {\n  if (typeof track.getCapabilities !== 'function') {\n    return;\n  }\n  const capabilities = track.getCapabilities();\n  const constraints = {};\n  const clampedValues = ['exposureCompensation', 'colorTemperature', 'iso', 'brightness', 'contrast', 'saturation', 'sharpness', 'focusDistance', 'zoom'];\n  for (const property of clampedValues) {\n    if (capabilities[property]) {\n      constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n    }\n  }\n  function validatedInternalConstrainedValue(constraintKey, settingsKey, converter) {\n    const convertedSetting = converter(settings[settingsKey]);\n    return validatedConstrainedValue({\n      constraintKey,\n      settingsKey,\n      convertedSetting,\n      capabilities,\n      settings,\n      cameraType\n    });\n  }\n  if (capabilities.focusMode && settings.autoFocus !== undefined) {\n    constraints.focusMode = validatedInternalConstrainedValue('focusMode', 'autoFocus', CapabilityUtils.convertAutoFocusJSONToNative);\n  }\n  if (capabilities.torch && settings.flashMode !== undefined) {\n    constraints.torch = validatedInternalConstrainedValue('torch', 'flashMode', CapabilityUtils.convertFlashModeJSONToNative);\n  }\n  if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n    constraints.whiteBalanceMode = validatedInternalConstrainedValue('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n  }\n  try {\n    await track.applyConstraints({\n      advanced: [constraints]\n    });\n  } catch (error) {\n    if (__DEV__) console.warn('Failed to apply constraints', error);\n  }\n}\nexport function stopMediaStream(stream) {\n  if (!stream) {\n    return;\n  }\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach(track => track.stop());\n  }\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach(track => track.stop());\n  }\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\nexport function setVideoSource(video, stream) {\n  const createObjectURL = window.URL.createObjectURL ?? window.webkitURL.createObjectURL;\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof video.mozSrcObject !== 'undefined') {\n    video.mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream);\n  }\n  if (!stream) {\n    const revokeObjectURL = window.URL.revokeObjectURL ?? window.webkitURL.revokeObjectURL;\n    const source = video.src ?? video.srcObject ?? video.mozSrcObject;\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\nexport function isCapabilityAvailable(video, keyName) {\n  const stream = video.srcObject;\n  if (stream instanceof MediaStream) {\n    const videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities?.()?.[keyName];\n  }\n  return false;\n}\nfunction isMediaStreamTrack(input) {\n  return typeof input.stop === 'function';\n}\nfunction convertNormalizedSetting(range, value) {\n  if (!value) {\n    return;\n  }\n  const converted = convertRange(value, [range.min, range.max]);\n  return Math.min(range.max, Math.max(range.min, converted));\n}\nfunction convertRange(value, r2, r1 = [0, 1]) {\n  return (value - r1[0]) * (r2[1] - r2[0]) / (r1[1] - r1[0]) + r2[0];\n}\nfunction validatedConstrainedValue(props) {\n  const {\n    constraintKey,\n    settingsKey,\n    convertedSetting,\n    capabilities,\n    settings,\n    cameraType\n  } = props;\n  const setting = settings[settingsKey];\n  if (Array.isArray(capabilities[constraintKey]) && convertedSetting && !capabilities[constraintKey].includes(convertedSetting)) {\n    if (__DEV__) {\n      console.warn(` { ${settingsKey}: \"${setting}\" } (converted to \"${convertedSetting}\" in the browser) is not supported for camera type \"${cameraType}\" in your browser. Using the default value instead.`);\n    }\n    return undefined;\n  }\n  return convertedSetting;\n}","map":{"version":3,"names":["invariant","CapabilityUtils","CameraTypeToFacingMode","ImageTypeFormat","MinimumConstraints","requestUserMediaAsync","getImageSize","videoWidth","videoHeight","scale","width","ratio","height","toDataURL","canvas","imageType","quality","types","includes","join","format","hasValidConstraints","preferredCameraType","undefined","ensureCameraPictureOptions","config","captureOptions","isImageMirror","key","DEFAULT_QUALITY","captureImageData","video","pictureOptions","readyState","HAVE_ENOUGH_DATA","captureImageContext","context","getContext","alpha","imageData","getImageData","document","createElement","Error","setTransform","drawImage","captureImage","getSupportedConstraints","navigator","mediaDevices","getIdealConstraints","preferredConstraints","audio","supports","facingMode","isWebKit","ideal","isMediaTrackConstraints","input","getPreferredStreamDevice","preferredWidth","preferredHeight","getStreamDevice","error","OverconstrainedError","constraint","nextCameraType","constraints","stream","test","userAgent","compareStreams","a","b","settingsA","getTracks","getSettings","settingsB","deviceId","capture","settings","base64","capturedPicture","uri","exif","onPictureSaved","syncTrackCapabilities","cameraType","getVideoTracks","Promise","all","map","track","onCapabilitiesReady","getCapabilities","capabilities","clampedValues","property","convertNormalizedSetting","validatedInternalConstrainedValue","constraintKey","settingsKey","converter","convertedSetting","validatedConstrainedValue","focusMode","autoFocus","convertAutoFocusJSONToNative","torch","flashMode","convertFlashModeJSONToNative","whiteBalanceMode","whiteBalance","convertWhiteBalanceJSONToNative","applyConstraints","advanced","__DEV__","console","warn","stopMediaStream","getAudioTracks","forEach","stop","isMediaStreamTrack","setVideoSource","createObjectURL","window","URL","webkitURL","srcObject","mozSrcObject","src","revokeObjectURL","source","isCapabilityAvailable","keyName","MediaStream","videoTrack","range","value","converted","convertRange","min","max","Math","r2","r1","props","setting","Array","isArray"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/expo-camera/src/web/WebCameraUtils.ts"],"sourcesContent":["/* eslint-env browser */\nimport invariant from 'invariant';\n\nimport * as CapabilityUtils from './WebCapabilityUtils';\nimport { CameraTypeToFacingMode, ImageTypeFormat, MinimumConstraints } from './WebConstants';\nimport { requestUserMediaAsync } from './WebUserMediaManager';\nimport {\n  CameraType,\n  CameraCapturedPicture,\n  ImageSize,\n  ImageType,\n  WebCameraSettings,\n  CameraPictureOptions,\n} from '../Camera.types';\n\ninterface ConstrainLongRange {\n  max?: number;\n  min?: number;\n  exact?: number;\n  ideal?: number;\n}\n\nexport function getImageSize(videoWidth: number, videoHeight: number, scale: number): ImageSize {\n  const width = videoWidth * scale;\n  const ratio = videoWidth / width;\n  const height = videoHeight / ratio;\n\n  return {\n    width,\n    height,\n  };\n}\n\nexport function toDataURL(\n  canvas: HTMLCanvasElement,\n  imageType: ImageType,\n  quality: number\n): string {\n  const types = ['png', 'jpg'];\n  invariant(\n    types.includes(imageType),\n    `expo-camera: ${imageType} is not a valid ImageType. Expected a string from: ${types.join(', ')}`\n  );\n\n  const format = ImageTypeFormat[imageType];\n  if (imageType === 'jpg') {\n    invariant(\n      quality <= 1 && quality >= 0,\n      `expo-camera: ${quality} is not a valid image quality. Expected a number from 0...1`\n    );\n    return canvas.toDataURL(format, quality);\n  } else {\n    return canvas.toDataURL(format);\n  }\n}\n\nexport function hasValidConstraints(\n  preferredCameraType?: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): boolean {\n  return preferredCameraType !== undefined && width !== undefined && height !== undefined;\n}\n\nfunction ensureCameraPictureOptions(config: CameraPictureOptions): CameraPictureOptions {\n  const captureOptions = {\n    scale: 1,\n    imageType: 'png' as ImageType,\n    isImageMirror: false,\n  };\n\n  for (const key in config) {\n    if (key in config && config[key] !== undefined && key in captureOptions) {\n      captureOptions[key] = config[key];\n    }\n  }\n  return captureOptions;\n}\n\nconst DEFAULT_QUALITY = 0.92;\n\nexport function captureImageData(\n  video: HTMLVideoElement | null,\n  pictureOptions: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'> = {}\n): ImageData | null {\n  if (!video || video.readyState !== video.HAVE_ENOUGH_DATA) {\n    return null;\n  }\n  const canvas = captureImageContext(video, pictureOptions);\n\n  const context = canvas.getContext('2d', { alpha: false });\n  if (!context || !canvas.width || !canvas.height) {\n    return null;\n  }\n\n  const imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n  return imageData;\n}\n\nexport function captureImageContext(\n  video: HTMLVideoElement,\n  { scale = 1, isImageMirror = false }: Pick<CameraPictureOptions, 'scale' | 'isImageMirror'>\n): HTMLCanvasElement {\n  const { videoWidth, videoHeight } = video;\n  const { width, height } = getImageSize(videoWidth, videoHeight, scale!);\n\n  // Build the canvas size and draw the camera image to the context from video\n  const canvas = document.createElement('canvas');\n  canvas.width = width;\n  canvas.height = height;\n  const context = canvas.getContext('2d', { alpha: false });\n\n  if (!context) {\n    // Should never be called\n    throw new Error('Context is not defined');\n  }\n  // sharp image details\n  // context.imageSmoothingEnabled = false;\n\n  // Flip horizontally (as css transform: rotateY(180deg))\n  if (isImageMirror) {\n    context.setTransform(-1, 0, 0, 1, canvas.width, 0);\n  }\n\n  context.drawImage(video, 0, 0, width, height);\n\n  return canvas;\n}\n\nexport function captureImage(\n  video: HTMLVideoElement,\n  pictureOptions: CameraPictureOptions\n): string {\n  const config = ensureCameraPictureOptions(pictureOptions);\n  const canvas = captureImageContext(video, config);\n  const { imageType, quality = DEFAULT_QUALITY } = config;\n  return toDataURL(canvas, imageType!, quality);\n}\n\nfunction getSupportedConstraints(): MediaTrackSupportedConstraints | null {\n  if (navigator.mediaDevices && navigator.mediaDevices.getSupportedConstraints) {\n    return navigator.mediaDevices.getSupportedConstraints();\n  }\n  return null;\n}\n\nexport function getIdealConstraints(\n  preferredCameraType: CameraType,\n  width?: number | ConstrainLongRange,\n  height?: number | ConstrainLongRange\n): MediaStreamConstraints {\n  const preferredConstraints: MediaStreamConstraints = {\n    audio: false,\n    video: {},\n  };\n\n  if (hasValidConstraints(preferredCameraType, width, height)) {\n    return MinimumConstraints;\n  }\n\n  const supports = getSupportedConstraints();\n  // TODO(Bacon): Test this\n  if (!supports || !supports.facingMode || !supports.width || !supports.height) {\n    return MinimumConstraints;\n  }\n  const types = ['front', 'back'];\n  if (preferredCameraType && types.includes(preferredCameraType)) {\n    const facingMode = CameraTypeToFacingMode[preferredCameraType];\n    if (isWebKit()) {\n      const key = facingMode === 'user' ? 'exact' : 'ideal';\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        [key]: facingMode,\n      };\n    } else {\n      (preferredConstraints.video as MediaTrackConstraints).facingMode = {\n        ideal: CameraTypeToFacingMode[preferredCameraType],\n      };\n    }\n  }\n\n  if (isMediaTrackConstraints(preferredConstraints.video)) {\n    preferredConstraints.video.width = width;\n    preferredConstraints.video.height = height;\n  }\n\n  return preferredConstraints;\n}\n\nfunction isMediaTrackConstraints(input: any): input is MediaTrackConstraints {\n  return input && typeof input.video !== 'boolean';\n}\n\n/**\n * Invoke getStreamDevice a second time with the opposing camera type if the preferred type cannot be retrieved.\n *\n * @param preferredCameraType\n * @param preferredWidth\n * @param preferredHeight\n */\nexport async function getPreferredStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  try {\n    return await getStreamDevice(preferredCameraType, preferredWidth, preferredHeight);\n  } catch (error) {\n    // A hack on desktop browsers to ensure any camera is used.\n    // eslint-disable-next-line no-undef\n    if (error instanceof OverconstrainedError && error.constraint === 'facingMode') {\n      const nextCameraType = preferredCameraType === 'back' ? 'front' : 'back';\n      return await getStreamDevice(nextCameraType, preferredWidth, preferredHeight);\n    }\n    throw error;\n  }\n}\n\nexport async function getStreamDevice(\n  preferredCameraType: CameraType,\n  preferredWidth?: number | ConstrainLongRange,\n  preferredHeight?: number | ConstrainLongRange\n): Promise<MediaStream> {\n  const constraints: MediaStreamConstraints = getIdealConstraints(\n    preferredCameraType,\n    preferredWidth,\n    preferredHeight\n  );\n  const stream: MediaStream = await requestUserMediaAsync(constraints);\n  return stream;\n}\n\nexport function isWebKit(): boolean {\n  return /WebKit/.test(navigator.userAgent) && !/Edg/.test(navigator.userAgent);\n}\n\nexport function compareStreams(a: MediaStream | null, b: MediaStream | null): boolean {\n  if (!a || !b) {\n    return false;\n  }\n  const settingsA = a.getTracks()[0].getSettings();\n  const settingsB = b.getTracks()[0].getSettings();\n  return settingsA.deviceId === settingsB.deviceId;\n}\n\nexport function capture(\n  video: HTMLVideoElement,\n  settings: MediaTrackSettings,\n  config: CameraPictureOptions\n): CameraCapturedPicture {\n  const base64 = captureImage(video, config);\n\n  const capturedPicture: CameraCapturedPicture = {\n    uri: base64,\n    base64,\n    width: 0,\n    height: 0,\n  };\n\n  if (settings) {\n    const { width = 0, height = 0 } = settings;\n    capturedPicture.width = width;\n    capturedPicture.height = height;\n    capturedPicture.exif = settings;\n  }\n\n  if (config.onPictureSaved) {\n    config.onPictureSaved(capturedPicture);\n  }\n  return capturedPicture;\n}\n\nexport async function syncTrackCapabilities(\n  cameraType: CameraType,\n  stream: MediaStream | null,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  if (stream?.getVideoTracks) {\n    await Promise.all(\n      stream.getVideoTracks().map((track) => onCapabilitiesReady(cameraType, track, settings))\n    );\n  }\n}\n\n// https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints\nasync function onCapabilitiesReady(\n  cameraType: CameraType,\n  track: MediaStreamTrack,\n  settings: WebCameraSettings = {}\n): Promise<void> {\n  if (typeof track.getCapabilities !== 'function') {\n    return;\n  }\n\n  const capabilities = track.getCapabilities();\n\n  // Create an empty object because if you set a constraint that isn't available an error will be thrown.\n  const constraints: MediaTrackConstraintSet = {};\n\n  // TODO(Bacon): Add `pointsOfInterest` support\n  const clampedValues = [\n    'exposureCompensation',\n    'colorTemperature',\n    'iso',\n    'brightness',\n    'contrast',\n    'saturation',\n    'sharpness',\n    'focusDistance',\n    'zoom',\n  ];\n\n  for (const property of clampedValues) {\n    if (capabilities[property]) {\n      constraints[property] = convertNormalizedSetting(capabilities[property], settings[property]);\n    }\n  }\n\n  function validatedInternalConstrainedValue<IConvertedType>(\n    constraintKey: string,\n    settingsKey: string,\n    converter: (settingValue: any) => IConvertedType\n  ) {\n    const convertedSetting = converter(settings[settingsKey]);\n    return validatedConstrainedValue({\n      constraintKey,\n      settingsKey,\n      convertedSetting,\n      capabilities,\n      settings,\n      cameraType,\n    });\n  }\n\n  if (capabilities.focusMode && settings.autoFocus !== undefined) {\n    constraints.focusMode = validatedInternalConstrainedValue<MediaTrackConstraintSet['focusMode']>(\n      'focusMode',\n      'autoFocus',\n      CapabilityUtils.convertAutoFocusJSONToNative\n    );\n  }\n\n  if (capabilities.torch && settings.flashMode !== undefined) {\n    constraints.torch = validatedInternalConstrainedValue<MediaTrackConstraintSet['torch']>(\n      'torch',\n      'flashMode',\n      CapabilityUtils.convertFlashModeJSONToNative\n    );\n  }\n\n  if (capabilities.whiteBalanceMode && settings.whiteBalance !== undefined) {\n    constraints.whiteBalanceMode = validatedInternalConstrainedValue<\n      MediaTrackConstraintSet['whiteBalanceMode']\n    >('whiteBalanceMode', 'whiteBalance', CapabilityUtils.convertWhiteBalanceJSONToNative);\n  }\n\n  try {\n    await track.applyConstraints({ advanced: [constraints] });\n  } catch (error) {\n    if (__DEV__) console.warn('Failed to apply constraints', error);\n  }\n}\n\nexport function stopMediaStream(stream: MediaStream | null) {\n  if (!stream) {\n    return;\n  }\n  if (stream.getAudioTracks) {\n    stream.getAudioTracks().forEach((track) => track.stop());\n  }\n  if (stream.getVideoTracks) {\n    stream.getVideoTracks().forEach((track) => track.stop());\n  }\n  if (isMediaStreamTrack(stream)) {\n    stream.stop();\n  }\n}\n\nexport function setVideoSource(\n  video: HTMLVideoElement,\n  stream: MediaStream | MediaSource | Blob | null\n): void {\n  const createObjectURL = window.URL.createObjectURL ?? window.webkitURL.createObjectURL;\n\n  if (typeof video.srcObject !== 'undefined') {\n    video.srcObject = stream;\n  } else if (typeof (video as any).mozSrcObject !== 'undefined') {\n    (video as any).mozSrcObject = stream;\n  } else if (stream && createObjectURL) {\n    video.src = createObjectURL(stream as MediaSource | Blob);\n  }\n\n  if (!stream) {\n    const revokeObjectURL = window.URL.revokeObjectURL ?? window.webkitURL.revokeObjectURL;\n    const source = video.src ?? video.srcObject ?? (video as any).mozSrcObject;\n    if (revokeObjectURL && typeof source === 'string') {\n      revokeObjectURL(source);\n    }\n  }\n}\n\nexport function isCapabilityAvailable(video: HTMLVideoElement, keyName: string): boolean {\n  const stream = video.srcObject;\n\n  if (stream instanceof MediaStream) {\n    const videoTrack = stream.getVideoTracks()[0];\n    return videoTrack.getCapabilities?.()?.[keyName];\n  }\n\n  return false;\n}\n\nfunction isMediaStreamTrack(input: any): input is MediaStreamTrack {\n  return typeof input.stop === 'function';\n}\n\nfunction convertNormalizedSetting(range: MediaSettingsRange, value?: number): number | undefined {\n  if (!value) {\n    return;\n  }\n  // convert the normalized incoming setting to the native camera zoom range\n  const converted = convertRange(value, [range.min, range.max]);\n  // clamp value so we don't get an error\n  return Math.min(range.max, Math.max(range.min, converted));\n}\n\nfunction convertRange(value: number, r2: number[], r1: number[] = [0, 1]): number {\n  return ((value - r1[0]) * (r2[1] - r2[0])) / (r1[1] - r1[0]) + r2[0];\n}\n\nfunction validatedConstrainedValue<T>(props: {\n  constraintKey: string;\n  settingsKey: string;\n  convertedSetting: T;\n  capabilities: MediaTrackCapabilities;\n  settings: WebCameraSettings;\n  cameraType: string;\n}): T | undefined {\n  const { constraintKey, settingsKey, convertedSetting, capabilities, settings, cameraType } =\n    props;\n  const setting = settings[settingsKey];\n  if (\n    Array.isArray(capabilities[constraintKey]) &&\n    convertedSetting &&\n    !capabilities[constraintKey].includes(convertedSetting)\n  ) {\n    if (__DEV__) {\n      // Only warn in dev mode.\n      console.warn(\n        ` { ${settingsKey}: \"${setting}\" } (converted to \"${convertedSetting}\" in the browser) is not supported for camera type \"${cameraType}\" in your browser. Using the default value instead.`\n      );\n    }\n    return undefined;\n  }\n  return convertedSetting;\n}\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}