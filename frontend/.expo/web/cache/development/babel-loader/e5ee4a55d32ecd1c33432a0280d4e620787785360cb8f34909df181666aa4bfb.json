{"ast":null,"code":"'use strict';\n\nimport EventTarget from 'event-target-shim';\nconst BlobManager = require(\"../Blob/BlobManager\");\nconst GlobalPerformanceLogger = require(\"../Utilities/GlobalPerformanceLogger\");\nconst RCTNetworking = require(\"./RCTNetworking\").default;\nconst base64 = require('base64-js');\nconst invariant = require('invariant');\nconst DEBUG_NETWORK_SEND_DELAY = false;\nif (BlobManager.isAvailable) {\n  BlobManager.addNetworkingHandler();\n}\nconst UNSENT = 0;\nconst OPENED = 1;\nconst HEADERS_RECEIVED = 2;\nconst LOADING = 3;\nconst DONE = 4;\nconst SUPPORTED_RESPONSE_TYPES = {\n  arraybuffer: typeof global.ArrayBuffer === 'function',\n  blob: typeof global.Blob === 'function',\n  document: false,\n  json: true,\n  text: true,\n  '': true\n};\nconst REQUEST_EVENTS = ['abort', 'error', 'load', 'loadstart', 'progress', 'timeout', 'loadend'];\nconst XHR_EVENTS = REQUEST_EVENTS.concat('readystatechange');\nclass XMLHttpRequestEventTarget extends EventTarget(...REQUEST_EVENTS) {}\nclass XMLHttpRequest extends EventTarget(...XHR_EVENTS) {\n  static UNSENT = UNSENT;\n  static OPENED = OPENED;\n  static HEADERS_RECEIVED = HEADERS_RECEIVED;\n  static LOADING = LOADING;\n  static DONE = DONE;\n  static _interceptor = null;\n  UNSENT = UNSENT;\n  OPENED = OPENED;\n  HEADERS_RECEIVED = HEADERS_RECEIVED;\n  LOADING = LOADING;\n  DONE = DONE;\n  readyState = UNSENT;\n  status = 0;\n  timeout = 0;\n  withCredentials = true;\n  upload = new XMLHttpRequestEventTarget();\n  _aborted = false;\n  _hasError = false;\n  _method = null;\n  _perfKey = null;\n  _response = '';\n  _url = null;\n  _timedOut = false;\n  _trackingName = 'unknown';\n  _incrementalEvents = false;\n  _performanceLogger = GlobalPerformanceLogger;\n  static setInterceptor(interceptor) {\n    XMLHttpRequest._interceptor = interceptor;\n  }\n  constructor() {\n    super();\n    this._reset();\n  }\n  _reset() {\n    this.readyState = this.UNSENT;\n    this.responseHeaders = undefined;\n    this.status = 0;\n    delete this.responseURL;\n    this._requestId = null;\n    this._cachedResponse = undefined;\n    this._hasError = false;\n    this._headers = {};\n    this._response = '';\n    this._responseType = '';\n    this._sent = false;\n    this._lowerCaseResponseHeaders = {};\n    this._clearSubscriptions();\n    this._timedOut = false;\n  }\n  get responseType() {\n    return this._responseType;\n  }\n  set responseType(responseType) {\n    if (this._sent) {\n      throw new Error(\"Failed to set the 'responseType' property on 'XMLHttpRequest': The \" + 'response type cannot be set after the request has been sent.');\n    }\n    if (!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {\n      console.warn(`The provided value '${responseType}' is not a valid 'responseType'.`);\n      return;\n    }\n    invariant(SUPPORTED_RESPONSE_TYPES[responseType] || responseType === 'document', `The provided value '${responseType}' is unsupported in this environment.`);\n    if (responseType === 'blob') {\n      invariant(BlobManager.isAvailable, 'Native module BlobModule is required for blob support');\n    }\n    this._responseType = responseType;\n  }\n  get responseText() {\n    if (this._responseType !== '' && this._responseType !== 'text') {\n      throw new Error(\"The 'responseText' property is only available if 'responseType' \" + `is set to '' or 'text', but it is '${this._responseType}'.`);\n    }\n    if (this.readyState < LOADING) {\n      return '';\n    }\n    return this._response;\n  }\n  get response() {\n    const {\n      responseType\n    } = this;\n    if (responseType === '' || responseType === 'text') {\n      return this.readyState < LOADING || this._hasError ? '' : this._response;\n    }\n    if (this.readyState !== DONE) {\n      return null;\n    }\n    if (this._cachedResponse !== undefined) {\n      return this._cachedResponse;\n    }\n    switch (responseType) {\n      case 'document':\n        this._cachedResponse = null;\n        break;\n      case 'arraybuffer':\n        this._cachedResponse = base64.toByteArray(this._response).buffer;\n        break;\n      case 'blob':\n        if (typeof this._response === 'object' && this._response) {\n          this._cachedResponse = BlobManager.createFromOptions(this._response);\n        } else if (this._response === '') {\n          this._cachedResponse = BlobManager.createFromParts([]);\n        } else {\n          throw new Error('Invalid response for blob - expecting object, was ' + `${typeof this._response}: ${this._response.trim()}`);\n        }\n        break;\n      case 'json':\n        try {\n          this._cachedResponse = JSON.parse(this._response);\n        } catch (_) {\n          this._cachedResponse = null;\n        }\n        break;\n      default:\n        this._cachedResponse = null;\n    }\n    return this._cachedResponse;\n  }\n  __didCreateRequest(requestId) {\n    this._requestId = requestId;\n    XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.requestSent(requestId, this._url || '', this._method || 'GET', this._headers);\n  }\n  __didUploadProgress(requestId, progress, total) {\n    if (requestId === this._requestId) {\n      this.upload.dispatchEvent({\n        type: 'progress',\n        lengthComputable: true,\n        loaded: progress,\n        total\n      });\n    }\n  }\n  __didReceiveResponse(requestId, status, responseHeaders, responseURL) {\n    if (requestId === this._requestId) {\n      this._perfKey != null && this._performanceLogger.stopTimespan(this._perfKey);\n      this.status = status;\n      this.setResponseHeaders(responseHeaders);\n      this.setReadyState(this.HEADERS_RECEIVED);\n      if (responseURL || responseURL === '') {\n        this.responseURL = responseURL;\n      } else {\n        delete this.responseURL;\n      }\n      XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.responseReceived(requestId, responseURL || this._url || '', status, responseHeaders || {});\n    }\n  }\n  __didReceiveData(requestId, response) {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    this._response = response;\n    this._cachedResponse = undefined;\n    this.setReadyState(this.LOADING);\n    XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, response);\n  }\n  __didReceiveIncrementalData(requestId, responseText, progress, total) {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    if (!this._response) {\n      this._response = responseText;\n    } else {\n      this._response += responseText;\n    }\n    XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.dataReceived(requestId, responseText);\n    this.setReadyState(this.LOADING);\n    this.__didReceiveDataProgress(requestId, progress, total);\n  }\n  __didReceiveDataProgress(requestId, loaded, total) {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    this.dispatchEvent({\n      type: 'progress',\n      lengthComputable: total >= 0,\n      loaded,\n      total\n    });\n  }\n  __didCompleteResponse(requestId, error, timeOutError) {\n    if (requestId === this._requestId) {\n      if (error) {\n        if (this._responseType === '' || this._responseType === 'text') {\n          this._response = error;\n        }\n        this._hasError = true;\n        if (timeOutError) {\n          this._timedOut = true;\n        }\n      }\n      this._clearSubscriptions();\n      this._requestId = null;\n      this.setReadyState(this.DONE);\n      if (error) {\n        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFailed(requestId, error);\n      } else {\n        XMLHttpRequest._interceptor && XMLHttpRequest._interceptor.loadingFinished(requestId, this._response.length);\n      }\n    }\n  }\n  _clearSubscriptions() {\n    (this._subscriptions || []).forEach(sub => {\n      if (sub) {\n        sub.remove();\n      }\n    });\n    this._subscriptions = [];\n  }\n  getAllResponseHeaders() {\n    if (!this.responseHeaders) {\n      return null;\n    }\n    const responseHeaders = this.responseHeaders;\n    const unsortedHeaders = new Map();\n    for (const rawHeaderName of Object.keys(responseHeaders)) {\n      const headerValue = responseHeaders[rawHeaderName];\n      const lowerHeaderName = rawHeaderName.toLowerCase();\n      const header = unsortedHeaders.get(lowerHeaderName);\n      if (header) {\n        header.headerValue += ', ' + headerValue;\n        unsortedHeaders.set(lowerHeaderName, header);\n      } else {\n        unsortedHeaders.set(lowerHeaderName, {\n          lowerHeaderName,\n          upperHeaderName: rawHeaderName.toUpperCase(),\n          headerValue\n        });\n      }\n    }\n    const sortedHeaders = [...unsortedHeaders.values()].sort((a, b) => {\n      if (a.upperHeaderName < b.upperHeaderName) {\n        return -1;\n      }\n      if (a.upperHeaderName > b.upperHeaderName) {\n        return 1;\n      }\n      return 0;\n    });\n    return sortedHeaders.map(header => {\n      return header.lowerHeaderName + ': ' + header.headerValue;\n    }).join('\\r\\n') + '\\r\\n';\n  }\n  getResponseHeader(header) {\n    const value = this._lowerCaseResponseHeaders[header.toLowerCase()];\n    return value !== undefined ? value : null;\n  }\n  setRequestHeader(header, value) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    this._headers[header.toLowerCase()] = String(value);\n  }\n  setTrackingName(trackingName) {\n    this._trackingName = trackingName;\n    return this;\n  }\n  setPerformanceLogger(performanceLogger) {\n    this._performanceLogger = performanceLogger;\n    return this;\n  }\n  open(method, url, async) {\n    if (this.readyState !== this.UNSENT) {\n      throw new Error('Cannot open, already sending');\n    }\n    if (async !== undefined && !async) {\n      throw new Error('Synchronous http requests are not supported');\n    }\n    if (!url) {\n      throw new Error('Cannot load an empty url');\n    }\n    this._method = method.toUpperCase();\n    this._url = url;\n    this._aborted = false;\n    this.setReadyState(this.OPENED);\n  }\n  send(data) {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    if (this._sent) {\n      throw new Error('Request has already been sent');\n    }\n    this._sent = true;\n    const incrementalEvents = this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;\n    this._subscriptions.push(RCTNetworking.addListener('didSendNetworkData', args => this.__didUploadProgress(...args)));\n    this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkResponse', args => this.__didReceiveResponse(...args)));\n    this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkData', args => this.__didReceiveData(...args)));\n    this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkIncrementalData', args => this.__didReceiveIncrementalData(...args)));\n    this._subscriptions.push(RCTNetworking.addListener('didReceiveNetworkDataProgress', args => this.__didReceiveDataProgress(...args)));\n    this._subscriptions.push(RCTNetworking.addListener('didCompleteNetworkResponse', args => this.__didCompleteResponse(...args)));\n    let nativeResponseType = 'text';\n    if (this._responseType === 'arraybuffer') {\n      nativeResponseType = 'base64';\n    }\n    if (this._responseType === 'blob') {\n      nativeResponseType = 'blob';\n    }\n    const doSend = () => {\n      const friendlyName = this._trackingName !== 'unknown' ? this._trackingName : this._url;\n      this._perfKey = 'network_XMLHttpRequest_' + String(friendlyName);\n      this._performanceLogger.startTimespan(this._perfKey);\n      invariant(this._method, 'XMLHttpRequest method needs to be defined (%s).', friendlyName);\n      invariant(this._url, 'XMLHttpRequest URL needs to be defined (%s).', friendlyName);\n      RCTNetworking.sendRequest(this._method, this._trackingName, this._url, this._headers, data, nativeResponseType, incrementalEvents, this.timeout, this.__didCreateRequest.bind(this), this.withCredentials);\n    };\n    if (DEBUG_NETWORK_SEND_DELAY) {\n      setTimeout(doSend, DEBUG_NETWORK_SEND_DELAY);\n    } else {\n      doSend();\n    }\n  }\n  abort() {\n    this._aborted = true;\n    if (this._requestId) {\n      RCTNetworking.abortRequest(this._requestId);\n    }\n    if (!(this.readyState === this.UNSENT || this.readyState === this.OPENED && !this._sent || this.readyState === this.DONE)) {\n      this._reset();\n      this.setReadyState(this.DONE);\n    }\n    this._reset();\n  }\n  setResponseHeaders(responseHeaders) {\n    this.responseHeaders = responseHeaders || null;\n    const headers = responseHeaders || {};\n    this._lowerCaseResponseHeaders = Object.keys(headers).reduce((lcaseHeaders, headerName) => {\n      lcaseHeaders[headerName.toLowerCase()] = headers[headerName];\n      return lcaseHeaders;\n    }, {});\n  }\n  setReadyState(newState) {\n    this.readyState = newState;\n    this.dispatchEvent({\n      type: 'readystatechange'\n    });\n    if (newState === this.DONE) {\n      if (this._aborted) {\n        this.dispatchEvent({\n          type: 'abort'\n        });\n      } else if (this._hasError) {\n        if (this._timedOut) {\n          this.dispatchEvent({\n            type: 'timeout'\n          });\n        } else {\n          this.dispatchEvent({\n            type: 'error'\n          });\n        }\n      } else {\n        this.dispatchEvent({\n          type: 'load'\n        });\n      }\n      this.dispatchEvent({\n        type: 'loadend'\n      });\n    }\n  }\n  addEventListener(type, listener) {\n    if (type === 'readystatechange' || type === 'progress') {\n      this._incrementalEvents = true;\n    }\n    super.addEventListener(type, listener);\n  }\n}\nmodule.exports = XMLHttpRequest;","map":{"version":3,"names":["EventTarget","BlobManager","require","GlobalPerformanceLogger","RCTNetworking","default","base64","invariant","DEBUG_NETWORK_SEND_DELAY","isAvailable","addNetworkingHandler","UNSENT","OPENED","HEADERS_RECEIVED","LOADING","DONE","SUPPORTED_RESPONSE_TYPES","arraybuffer","global","ArrayBuffer","blob","Blob","document","json","text","REQUEST_EVENTS","XHR_EVENTS","concat","XMLHttpRequestEventTarget","XMLHttpRequest","_interceptor","readyState","status","timeout","withCredentials","upload","_aborted","_hasError","_method","_perfKey","_response","_url","_timedOut","_trackingName","_incrementalEvents","_performanceLogger","setInterceptor","interceptor","constructor","_reset","responseHeaders","undefined","responseURL","_requestId","_cachedResponse","_headers","_responseType","_sent","_lowerCaseResponseHeaders","_clearSubscriptions","responseType","Error","hasOwnProperty","console","warn","responseText","response","toByteArray","buffer","createFromOptions","createFromParts","trim","JSON","parse","_","__didCreateRequest","requestId","requestSent","__didUploadProgress","progress","total","dispatchEvent","type","lengthComputable","loaded","__didReceiveResponse","stopTimespan","setResponseHeaders","setReadyState","responseReceived","__didReceiveData","dataReceived","__didReceiveIncrementalData","__didReceiveDataProgress","__didCompleteResponse","error","timeOutError","loadingFailed","loadingFinished","length","_subscriptions","forEach","sub","remove","getAllResponseHeaders","unsortedHeaders","Map","rawHeaderName","Object","keys","headerValue","lowerHeaderName","toLowerCase","header","get","set","upperHeaderName","toUpperCase","sortedHeaders","values","sort","a","b","map","join","getResponseHeader","value","setRequestHeader","String","setTrackingName","trackingName","setPerformanceLogger","performanceLogger","open","method","url","async","send","data","incrementalEvents","onreadystatechange","onprogress","push","addListener","args","nativeResponseType","doSend","friendlyName","startTimespan","sendRequest","bind","setTimeout","abort","abortRequest","headers","reduce","lcaseHeaders","headerName","newState","addEventListener","listener","module","exports"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/react-native/Libraries/Network/XMLHttpRequest.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nimport type {IPerformanceLogger} from '../Utilities/createPerformanceLogger';\n\nimport {type EventSubscription} from '../vendor/emitter/EventEmitter';\nimport EventTarget from 'event-target-shim';\n\nconst BlobManager = require('../Blob/BlobManager');\nconst GlobalPerformanceLogger = require('../Utilities/GlobalPerformanceLogger');\nconst RCTNetworking = require('./RCTNetworking').default;\nconst base64 = require('base64-js');\nconst invariant = require('invariant');\n\nconst DEBUG_NETWORK_SEND_DELAY: false = false; // Set to a number of milliseconds when debugging\n\nexport type NativeResponseType = 'base64' | 'blob' | 'text';\nexport type ResponseType =\n  | ''\n  | 'arraybuffer'\n  | 'blob'\n  | 'document'\n  | 'json'\n  | 'text';\nexport type Response = ?Object | string;\n\ntype XHRInterceptor = interface {\n  requestSent(id: number, url: string, method: string, headers: Object): void,\n  responseReceived(\n    id: number,\n    url: string,\n    status: number,\n    headers: Object,\n  ): void,\n  dataReceived(id: number, data: string): void,\n  loadingFinished(id: number, encodedDataLength: number): void,\n  loadingFailed(id: number, error: string): void,\n};\n\n// The native blob module is optional so inject it here if available.\nif (BlobManager.isAvailable) {\n  BlobManager.addNetworkingHandler();\n}\n\nconst UNSENT = 0;\nconst OPENED = 1;\nconst HEADERS_RECEIVED = 2;\nconst LOADING = 3;\nconst DONE = 4;\n\nconst SUPPORTED_RESPONSE_TYPES = {\n  arraybuffer: typeof global.ArrayBuffer === 'function',\n  blob: typeof global.Blob === 'function',\n  document: false,\n  json: true,\n  text: true,\n  '': true,\n};\n\nconst REQUEST_EVENTS = [\n  'abort',\n  'error',\n  'load',\n  'loadstart',\n  'progress',\n  'timeout',\n  'loadend',\n];\n\nconst XHR_EVENTS = REQUEST_EVENTS.concat('readystatechange');\n\nclass XMLHttpRequestEventTarget extends (EventTarget(\n  ...REQUEST_EVENTS,\n): typeof EventTarget) {\n  onload: ?Function;\n  onloadstart: ?Function;\n  onprogress: ?Function;\n  ontimeout: ?Function;\n  onerror: ?Function;\n  onabort: ?Function;\n  onloadend: ?Function;\n}\n\n/**\n * Shared base for platform-specific XMLHttpRequest implementations.\n */\nclass XMLHttpRequest extends (EventTarget(...XHR_EVENTS): typeof EventTarget) {\n  static UNSENT: number = UNSENT;\n  static OPENED: number = OPENED;\n  static HEADERS_RECEIVED: number = HEADERS_RECEIVED;\n  static LOADING: number = LOADING;\n  static DONE: number = DONE;\n\n  static _interceptor: ?XHRInterceptor = null;\n\n  UNSENT: number = UNSENT;\n  OPENED: number = OPENED;\n  HEADERS_RECEIVED: number = HEADERS_RECEIVED;\n  LOADING: number = LOADING;\n  DONE: number = DONE;\n\n  // EventTarget automatically initializes these to `null`.\n  onload: ?Function;\n  onloadstart: ?Function;\n  onprogress: ?Function;\n  ontimeout: ?Function;\n  onerror: ?Function;\n  onabort: ?Function;\n  onloadend: ?Function;\n  onreadystatechange: ?Function;\n\n  readyState: number = UNSENT;\n  responseHeaders: ?Object;\n  status: number = 0;\n  timeout: number = 0;\n  responseURL: ?string;\n  withCredentials: boolean = true;\n\n  upload: XMLHttpRequestEventTarget = new XMLHttpRequestEventTarget();\n\n  _requestId: ?number;\n  _subscriptions: Array<EventSubscription>;\n\n  _aborted: boolean = false;\n  _cachedResponse: Response;\n  _hasError: boolean = false;\n  _headers: Object;\n  _lowerCaseResponseHeaders: Object;\n  _method: ?string = null;\n  _perfKey: ?string = null;\n  _responseType: ResponseType;\n  _response: string = '';\n  _sent: boolean;\n  _url: ?string = null;\n  _timedOut: boolean = false;\n  _trackingName: string = 'unknown';\n  _incrementalEvents: boolean = false;\n  _performanceLogger: IPerformanceLogger = GlobalPerformanceLogger;\n\n  static setInterceptor(interceptor: ?XHRInterceptor) {\n    XMLHttpRequest._interceptor = interceptor;\n  }\n\n  constructor() {\n    super();\n    this._reset();\n  }\n\n  _reset(): void {\n    this.readyState = this.UNSENT;\n    this.responseHeaders = undefined;\n    this.status = 0;\n    delete this.responseURL;\n\n    this._requestId = null;\n\n    this._cachedResponse = undefined;\n    this._hasError = false;\n    this._headers = {};\n    this._response = '';\n    this._responseType = '';\n    this._sent = false;\n    this._lowerCaseResponseHeaders = {};\n\n    this._clearSubscriptions();\n    this._timedOut = false;\n  }\n\n  get responseType(): ResponseType {\n    return this._responseType;\n  }\n\n  set responseType(responseType: ResponseType): void {\n    if (this._sent) {\n      throw new Error(\n        \"Failed to set the 'responseType' property on 'XMLHttpRequest': The \" +\n          'response type cannot be set after the request has been sent.',\n      );\n    }\n    if (!SUPPORTED_RESPONSE_TYPES.hasOwnProperty(responseType)) {\n      console.warn(\n        `The provided value '${responseType}' is not a valid 'responseType'.`,\n      );\n      return;\n    }\n\n    // redboxes early, e.g. for 'arraybuffer' on ios 7\n    invariant(\n      SUPPORTED_RESPONSE_TYPES[responseType] || responseType === 'document',\n      `The provided value '${responseType}' is unsupported in this environment.`,\n    );\n\n    if (responseType === 'blob') {\n      invariant(\n        BlobManager.isAvailable,\n        'Native module BlobModule is required for blob support',\n      );\n    }\n    this._responseType = responseType;\n  }\n\n  get responseText(): string {\n    if (this._responseType !== '' && this._responseType !== 'text') {\n      throw new Error(\n        \"The 'responseText' property is only available if 'responseType' \" +\n          `is set to '' or 'text', but it is '${this._responseType}'.`,\n      );\n    }\n    if (this.readyState < LOADING) {\n      return '';\n    }\n    return this._response;\n  }\n\n  get response(): Response {\n    const {responseType} = this;\n    if (responseType === '' || responseType === 'text') {\n      return this.readyState < LOADING || this._hasError ? '' : this._response;\n    }\n\n    if (this.readyState !== DONE) {\n      return null;\n    }\n\n    if (this._cachedResponse !== undefined) {\n      return this._cachedResponse;\n    }\n\n    switch (responseType) {\n      case 'document':\n        this._cachedResponse = null;\n        break;\n\n      case 'arraybuffer':\n        this._cachedResponse = base64.toByteArray(this._response).buffer;\n        break;\n\n      case 'blob':\n        if (typeof this._response === 'object' && this._response) {\n          this._cachedResponse = BlobManager.createFromOptions(this._response);\n        } else if (this._response === '') {\n          this._cachedResponse = BlobManager.createFromParts([]);\n        } else {\n          throw new Error(\n            'Invalid response for blob - expecting object, was ' +\n              `${typeof this._response}: ${this._response.trim()}`,\n          );\n        }\n        break;\n\n      case 'json':\n        try {\n          this._cachedResponse = JSON.parse(this._response);\n        } catch (_) {\n          this._cachedResponse = null;\n        }\n        break;\n\n      default:\n        this._cachedResponse = null;\n    }\n\n    return this._cachedResponse;\n  }\n\n  // exposed for testing\n  __didCreateRequest(requestId: number): void {\n    this._requestId = requestId;\n\n    XMLHttpRequest._interceptor &&\n      XMLHttpRequest._interceptor.requestSent(\n        requestId,\n        this._url || '',\n        this._method || 'GET',\n        this._headers,\n      );\n  }\n\n  // exposed for testing\n  __didUploadProgress(\n    requestId: number,\n    progress: number,\n    total: number,\n  ): void {\n    if (requestId === this._requestId) {\n      this.upload.dispatchEvent({\n        type: 'progress',\n        lengthComputable: true,\n        loaded: progress,\n        total,\n      });\n    }\n  }\n\n  __didReceiveResponse(\n    requestId: number,\n    status: number,\n    responseHeaders: ?Object,\n    responseURL: ?string,\n  ): void {\n    if (requestId === this._requestId) {\n      this._perfKey != null &&\n        this._performanceLogger.stopTimespan(this._perfKey);\n      this.status = status;\n      this.setResponseHeaders(responseHeaders);\n      this.setReadyState(this.HEADERS_RECEIVED);\n      if (responseURL || responseURL === '') {\n        this.responseURL = responseURL;\n      } else {\n        delete this.responseURL;\n      }\n\n      XMLHttpRequest._interceptor &&\n        XMLHttpRequest._interceptor.responseReceived(\n          requestId,\n          responseURL || this._url || '',\n          status,\n          responseHeaders || {},\n        );\n    }\n  }\n\n  __didReceiveData(requestId: number, response: string): void {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    this._response = response;\n    this._cachedResponse = undefined; // force lazy recomputation\n    this.setReadyState(this.LOADING);\n\n    XMLHttpRequest._interceptor &&\n      XMLHttpRequest._interceptor.dataReceived(requestId, response);\n  }\n\n  __didReceiveIncrementalData(\n    requestId: number,\n    responseText: string,\n    progress: number,\n    total: number,\n  ) {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    if (!this._response) {\n      this._response = responseText;\n    } else {\n      this._response += responseText;\n    }\n\n    XMLHttpRequest._interceptor &&\n      XMLHttpRequest._interceptor.dataReceived(requestId, responseText);\n\n    this.setReadyState(this.LOADING);\n    this.__didReceiveDataProgress(requestId, progress, total);\n  }\n\n  __didReceiveDataProgress(\n    requestId: number,\n    loaded: number,\n    total: number,\n  ): void {\n    if (requestId !== this._requestId) {\n      return;\n    }\n    this.dispatchEvent({\n      type: 'progress',\n      lengthComputable: total >= 0,\n      loaded,\n      total,\n    });\n  }\n\n  // exposed for testing\n  __didCompleteResponse(\n    requestId: number,\n    error: string,\n    timeOutError: boolean,\n  ): void {\n    if (requestId === this._requestId) {\n      if (error) {\n        if (this._responseType === '' || this._responseType === 'text') {\n          this._response = error;\n        }\n        this._hasError = true;\n        if (timeOutError) {\n          this._timedOut = true;\n        }\n      }\n      this._clearSubscriptions();\n      this._requestId = null;\n      this.setReadyState(this.DONE);\n\n      if (error) {\n        XMLHttpRequest._interceptor &&\n          XMLHttpRequest._interceptor.loadingFailed(requestId, error);\n      } else {\n        XMLHttpRequest._interceptor &&\n          XMLHttpRequest._interceptor.loadingFinished(\n            requestId,\n            this._response.length,\n          );\n      }\n    }\n  }\n\n  _clearSubscriptions(): void {\n    (this._subscriptions || []).forEach(sub => {\n      if (sub) {\n        sub.remove();\n      }\n    });\n    this._subscriptions = [];\n  }\n\n  getAllResponseHeaders(): ?string {\n    if (!this.responseHeaders) {\n      // according to the spec, return null if no response has been received\n      return null;\n    }\n\n    // Assign to non-nullable local variable.\n    const responseHeaders = this.responseHeaders;\n\n    const unsortedHeaders: Map<\n      string,\n      {lowerHeaderName: string, upperHeaderName: string, headerValue: string},\n    > = new Map();\n    for (const rawHeaderName of Object.keys(responseHeaders)) {\n      const headerValue = responseHeaders[rawHeaderName];\n      const lowerHeaderName = rawHeaderName.toLowerCase();\n      const header = unsortedHeaders.get(lowerHeaderName);\n      if (header) {\n        header.headerValue += ', ' + headerValue;\n        unsortedHeaders.set(lowerHeaderName, header);\n      } else {\n        unsortedHeaders.set(lowerHeaderName, {\n          lowerHeaderName,\n          upperHeaderName: rawHeaderName.toUpperCase(),\n          headerValue,\n        });\n      }\n    }\n\n    // Sort in ascending order, with a being less than b if a's name is legacy-uppercased-byte less than b's name.\n    const sortedHeaders = [...unsortedHeaders.values()].sort((a, b) => {\n      if (a.upperHeaderName < b.upperHeaderName) {\n        return -1;\n      }\n      if (a.upperHeaderName > b.upperHeaderName) {\n        return 1;\n      }\n      return 0;\n    });\n\n    // Combine into single text response.\n    return (\n      sortedHeaders\n        .map(header => {\n          return header.lowerHeaderName + ': ' + header.headerValue;\n        })\n        .join('\\r\\n') + '\\r\\n'\n    );\n  }\n\n  getResponseHeader(header: string): ?string {\n    const value = this._lowerCaseResponseHeaders[header.toLowerCase()];\n    return value !== undefined ? value : null;\n  }\n\n  setRequestHeader(header: string, value: any): void {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    this._headers[header.toLowerCase()] = String(value);\n  }\n\n  /**\n   * Custom extension for tracking origins of request.\n   */\n  setTrackingName(trackingName: string): XMLHttpRequest {\n    this._trackingName = trackingName;\n    return this;\n  }\n\n  /**\n   * Custom extension for setting a custom performance logger\n   */\n  setPerformanceLogger(performanceLogger: IPerformanceLogger): XMLHttpRequest {\n    this._performanceLogger = performanceLogger;\n    return this;\n  }\n\n  open(method: string, url: string, async: ?boolean): void {\n    /* Other optional arguments are not supported yet */\n    if (this.readyState !== this.UNSENT) {\n      throw new Error('Cannot open, already sending');\n    }\n    if (async !== undefined && !async) {\n      // async is default\n      throw new Error('Synchronous http requests are not supported');\n    }\n    if (!url) {\n      throw new Error('Cannot load an empty url');\n    }\n    this._method = method.toUpperCase();\n    this._url = url;\n    this._aborted = false;\n    this.setReadyState(this.OPENED);\n  }\n\n  send(data: any): void {\n    if (this.readyState !== this.OPENED) {\n      throw new Error('Request has not been opened');\n    }\n    if (this._sent) {\n      throw new Error('Request has already been sent');\n    }\n    this._sent = true;\n    const incrementalEvents =\n      this._incrementalEvents || !!this.onreadystatechange || !!this.onprogress;\n\n    this._subscriptions.push(\n      RCTNetworking.addListener('didSendNetworkData', args =>\n        this.__didUploadProgress(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkResponse', args =>\n        this.__didReceiveResponse(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkData', args =>\n        this.__didReceiveData(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkIncrementalData', args =>\n        this.__didReceiveIncrementalData(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didReceiveNetworkDataProgress', args =>\n        this.__didReceiveDataProgress(...args),\n      ),\n    );\n    this._subscriptions.push(\n      RCTNetworking.addListener('didCompleteNetworkResponse', args =>\n        this.__didCompleteResponse(...args),\n      ),\n    );\n\n    let nativeResponseType: NativeResponseType = 'text';\n    if (this._responseType === 'arraybuffer') {\n      nativeResponseType = 'base64';\n    }\n    if (this._responseType === 'blob') {\n      nativeResponseType = 'blob';\n    }\n\n    const doSend = () => {\n      const friendlyName =\n        this._trackingName !== 'unknown' ? this._trackingName : this._url;\n      this._perfKey = 'network_XMLHttpRequest_' + String(friendlyName);\n      this._performanceLogger.startTimespan(this._perfKey);\n      invariant(\n        this._method,\n        'XMLHttpRequest method needs to be defined (%s).',\n        friendlyName,\n      );\n      invariant(\n        this._url,\n        'XMLHttpRequest URL needs to be defined (%s).',\n        friendlyName,\n      );\n      RCTNetworking.sendRequest(\n        this._method,\n        this._trackingName,\n        this._url,\n        this._headers,\n        data,\n        /* $FlowFixMe(>=0.78.0 site=react_native_android_fb) This issue was found\n         * when making Flow check .android.js files. */\n        nativeResponseType,\n        incrementalEvents,\n        this.timeout,\n        // $FlowFixMe[method-unbinding] added when improving typing for this parameters\n        this.__didCreateRequest.bind(this),\n        this.withCredentials,\n      );\n    };\n    if (DEBUG_NETWORK_SEND_DELAY) {\n      setTimeout(doSend, DEBUG_NETWORK_SEND_DELAY);\n    } else {\n      doSend();\n    }\n  }\n\n  abort(): void {\n    this._aborted = true;\n    if (this._requestId) {\n      RCTNetworking.abortRequest(this._requestId);\n    }\n    // only call onreadystatechange if there is something to abort,\n    // below logic is per spec\n    if (\n      !(\n        this.readyState === this.UNSENT ||\n        (this.readyState === this.OPENED && !this._sent) ||\n        this.readyState === this.DONE\n      )\n    ) {\n      this._reset();\n      this.setReadyState(this.DONE);\n    }\n    // Reset again after, in case modified in handler\n    this._reset();\n  }\n\n  setResponseHeaders(responseHeaders: ?Object): void {\n    this.responseHeaders = responseHeaders || null;\n    const headers = responseHeaders || {};\n    this._lowerCaseResponseHeaders = Object.keys(headers).reduce<{\n      [string]: any,\n    }>((lcaseHeaders, headerName) => {\n      // $FlowFixMe[invalid-computed-prop]\n      lcaseHeaders[headerName.toLowerCase()] = headers[headerName];\n      return lcaseHeaders;\n    }, {});\n  }\n\n  setReadyState(newState: number): void {\n    this.readyState = newState;\n    this.dispatchEvent({type: 'readystatechange'});\n    if (newState === this.DONE) {\n      if (this._aborted) {\n        this.dispatchEvent({type: 'abort'});\n      } else if (this._hasError) {\n        if (this._timedOut) {\n          this.dispatchEvent({type: 'timeout'});\n        } else {\n          this.dispatchEvent({type: 'error'});\n        }\n      } else {\n        this.dispatchEvent({type: 'load'});\n      }\n      this.dispatchEvent({type: 'loadend'});\n    }\n  }\n\n  /* global EventListener */\n  addEventListener(type: string, listener: EventListener): void {\n    // If we dont' have a 'readystatechange' event handler, we don't\n    // have to send repeated LOADING events with incremental updates\n    // to responseText, which will avoid a bunch of native -> JS\n    // bridge traffic.\n    if (type === 'readystatechange' || type === 'progress') {\n      this._incrementalEvents = true;\n    }\n    super.addEventListener(type, listener);\n  }\n}\n\nmodule.exports = XMLHttpRequest;\n"],"mappings":"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"},"metadata":{"hasCjsExports":true},"sourceType":"module","externalDependencies":[]}