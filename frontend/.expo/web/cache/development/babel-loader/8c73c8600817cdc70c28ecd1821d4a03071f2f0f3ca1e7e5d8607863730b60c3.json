{"ast":null,"code":"'use strict';\n\nconst processColor = require(\"./processColor\").default;\nconst DIRECTION_REGEX = /^to\\s+(?:top|bottom|left|right)(?:\\s+(?:top|bottom|left|right))?/;\nconst ANGLE_UNIT_REGEX = /^([+-]?\\d*\\.?\\d+)(deg|grad|rad|turn)$/i;\nconst TO_BOTTOM_START_END_POINTS = {\n  start: {\n    x: 0.5,\n    y: 0\n  },\n  end: {\n    x: 0.5,\n    y: 1\n  }\n};\nexport default function processBackgroundImage(backgroundImage) {\n  let result = [];\n  if (backgroundImage == null) {\n    return result;\n  }\n  if (typeof backgroundImage === 'string') {\n    result = parseCSSLinearGradient(backgroundImage.replace(/\\n/g, ' '));\n  } else if (Array.isArray(backgroundImage)) {\n    for (const bgImage of backgroundImage) {\n      const processedColorStops = [];\n      for (let index = 0; index < bgImage.colorStops.length; index++) {\n        const colorStop = bgImage.colorStops[index];\n        const processedColor = processColor(colorStop.color);\n        if (processedColor == null) {\n          return [];\n        }\n        if (colorStop.positions != null && colorStop.positions.length > 0) {\n          for (const position of colorStop.positions) {\n            if (position.endsWith('%')) {\n              processedColorStops.push({\n                color: processedColor,\n                position: parseFloat(position) / 100\n              });\n            } else {\n              return [];\n            }\n          }\n        } else {\n          processedColorStops.push({\n            color: processedColor,\n            position: null\n          });\n        }\n      }\n      let points = null;\n      if (typeof bgImage.direction === 'undefined') {\n        points = TO_BOTTOM_START_END_POINTS;\n      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n        const angle = parseAngle(bgImage.direction);\n        if (angle != null) {\n          points = calculateStartEndPointsFromAngle(angle);\n        }\n      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n        const processedPoints = calculateStartEndPointsFromDirection(bgImage.direction);\n        if (processedPoints != null) {\n          points = processedPoints;\n        }\n      }\n      const fixedColorStops = getFixedColorStops(processedColorStops);\n      if (points != null) {\n        result = result.concat({\n          type: 'linearGradient',\n          start: points.start,\n          end: points.end,\n          colorStops: fixedColorStops\n        });\n      }\n    }\n  }\n  return result;\n}\nfunction parseCSSLinearGradient(cssString) {\n  const gradients = [];\n  let match;\n  const linearGradientRegex = /linear-gradient\\s*\\(((?:\\([^)]*\\)|[^())])*)\\)/gi;\n  while (match = linearGradientRegex.exec(cssString)) {\n    const gradientContent = match[1];\n    const parts = gradientContent.split(',');\n    let points = TO_BOTTOM_START_END_POINTS;\n    const trimmedDirection = parts[0].trim().toLowerCase();\n    const colorStopRegex = /\\s*((?:(?:rgba?|hsla?)\\s*\\([^)]+\\))|#[0-9a-fA-F]+|[a-zA-Z]+)(?:\\s+(-?[0-9.]+%?)(?:\\s+(-?[0-9.]+%?))?)?\\s*/gi;\n    if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n      const angle = parseAngle(trimmedDirection);\n      if (angle != null) {\n        points = calculateStartEndPointsFromAngle(angle);\n        parts.shift();\n      } else {\n        return [];\n      }\n    } else if (DIRECTION_REGEX.test(trimmedDirection)) {\n      const parsedPoints = calculateStartEndPointsFromDirection(trimmedDirection);\n      if (parsedPoints != null) {\n        points = parsedPoints;\n        parts.shift();\n      } else {\n        return [];\n      }\n    } else if (!colorStopRegex.test(trimmedDirection)) {\n      return [];\n    }\n    colorStopRegex.lastIndex = 0;\n    const colorStops = [];\n    const fullColorStopsStr = parts.join(',');\n    let colorStopMatch;\n    while (colorStopMatch = colorStopRegex.exec(fullColorStopsStr)) {\n      const [, color, position1, position2] = colorStopMatch;\n      const processedColor = processColor(color.trim().toLowerCase());\n      if (processedColor == null) {\n        return [];\n      }\n      if (typeof position1 !== 'undefined') {\n        if (position1.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position1) / 100\n          });\n        } else {\n          return [];\n        }\n      } else {\n        colorStops.push({\n          color: processedColor,\n          position: null\n        });\n      }\n      if (typeof position2 !== 'undefined') {\n        if (position2.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position2) / 100\n          });\n        } else {\n          return [];\n        }\n      }\n    }\n    const fixedColorStops = getFixedColorStops(colorStops);\n    gradients.push({\n      type: 'linearGradient',\n      start: points.start,\n      end: points.end,\n      colorStops: fixedColorStops\n    });\n  }\n  return gradients;\n}\nfunction calculateStartEndPointsFromDirection(direction) {\n  const normalizedDirection = direction.replace(/\\s+/g, ' ');\n  switch (normalizedDirection) {\n    case 'to right':\n      return {\n        start: {\n          x: 0,\n          y: 0.5\n        },\n        end: {\n          x: 1,\n          y: 0.5\n        }\n      };\n    case 'to left':\n      return {\n        start: {\n          x: 1,\n          y: 0.5\n        },\n        end: {\n          x: 0,\n          y: 0.5\n        }\n      };\n    case 'to bottom':\n      return TO_BOTTOM_START_END_POINTS;\n    case 'to top':\n      return {\n        start: {\n          x: 0.5,\n          y: 1\n        },\n        end: {\n          x: 0.5,\n          y: 0\n        }\n      };\n    case 'to bottom right':\n    case 'to right bottom':\n      return {\n        start: {\n          x: 0,\n          y: 0\n        },\n        end: {\n          x: 1,\n          y: 1\n        }\n      };\n    case 'to top left':\n    case 'to left top':\n      return {\n        start: {\n          x: 1,\n          y: 1\n        },\n        end: {\n          x: 0,\n          y: 0\n        }\n      };\n    case 'to bottom left':\n    case 'to left bottom':\n      return {\n        start: {\n          x: 1,\n          y: 0\n        },\n        end: {\n          x: 0,\n          y: 1\n        }\n      };\n    case 'to top right':\n    case 'to right top':\n      return {\n        start: {\n          x: 0,\n          y: 1\n        },\n        end: {\n          x: 1,\n          y: 0\n        }\n      };\n    default:\n      return null;\n  }\n}\nfunction calculateStartEndPointsFromAngle(angleRadians) {\n  let angleRadiansNormalized = angleRadians % (2 * Math.PI);\n  if (angleRadiansNormalized < 0) {\n    angleRadiansNormalized += 2 * Math.PI;\n  }\n  const endX = 0.5 + 0.5 * Math.sin(angleRadiansNormalized);\n  const endY = 0.5 - 0.5 * Math.cos(angleRadiansNormalized);\n  const startX = 1 - endX;\n  const startY = 1 - endY;\n  return {\n    start: {\n      x: startX,\n      y: startY\n    },\n    end: {\n      x: endX,\n      y: endY\n    }\n  };\n}\nfunction parseAngle(angle) {\n  const match = angle.match(ANGLE_UNIT_REGEX);\n  if (!match) {\n    return null;\n  }\n  const [, value, unit] = match;\n  const numericValue = parseFloat(value);\n  switch (unit) {\n    case 'deg':\n      return numericValue * Math.PI / 180;\n    case 'grad':\n      return numericValue * Math.PI / 200;\n    case 'rad':\n      return numericValue;\n    case 'turn':\n      return numericValue * 2 * Math.PI;\n    default:\n      return null;\n  }\n}\nfunction getFixedColorStops(colorStops) {\n  let fixedColorStops = [];\n  let hasNullPositions = false;\n  let maxPositionSoFar = colorStops[0].position ?? 0;\n  for (let i = 0; i < colorStops.length; i++) {\n    const colorStop = colorStops[i];\n    let newPosition = colorStop.position;\n    if (newPosition === null) {\n      if (i === 0) {\n        newPosition = 0;\n      } else if (i === colorStops.length - 1) {\n        newPosition = 1;\n      }\n    }\n    if (newPosition !== null) {\n      newPosition = Math.max(newPosition, maxPositionSoFar);\n      fixedColorStops[i] = {\n        color: colorStop.color,\n        position: newPosition\n      };\n      maxPositionSoFar = newPosition;\n    } else {\n      hasNullPositions = true;\n    }\n  }\n  if (hasNullPositions) {\n    let lastDefinedIndex = 0;\n    for (let i = 1; i < fixedColorStops.length; i++) {\n      if (fixedColorStops[i] !== undefined) {\n        const unpositionedStops = i - lastDefinedIndex - 1;\n        if (unpositionedStops > 0) {\n          const startPosition = fixedColorStops[lastDefinedIndex].position;\n          const endPosition = fixedColorStops[i].position;\n          const increment = (endPosition - startPosition) / (unpositionedStops + 1);\n          for (let j = 1; j <= unpositionedStops; j++) {\n            fixedColorStops[lastDefinedIndex + j] = {\n              color: colorStops[lastDefinedIndex + j].color,\n              position: startPosition + increment * j\n            };\n          }\n        }\n        lastDefinedIndex = i;\n      }\n    }\n  }\n  return fixedColorStops;\n}","map":{"version":3,"names":["processColor","require","default","DIRECTION_REGEX","ANGLE_UNIT_REGEX","TO_BOTTOM_START_END_POINTS","start","x","y","end","processBackgroundImage","backgroundImage","result","parseCSSLinearGradient","replace","Array","isArray","bgImage","processedColorStops","index","colorStops","length","colorStop","processedColor","color","positions","position","endsWith","push","parseFloat","points","direction","test","angle","parseAngle","calculateStartEndPointsFromAngle","processedPoints","calculateStartEndPointsFromDirection","fixedColorStops","getFixedColorStops","concat","type","cssString","gradients","match","linearGradientRegex","exec","gradientContent","parts","split","trimmedDirection","trim","toLowerCase","colorStopRegex","shift","parsedPoints","lastIndex","fullColorStopsStr","join","colorStopMatch","position1","position2","normalizedDirection","angleRadians","angleRadiansNormalized","Math","PI","endX","sin","endY","cos","startX","startY","value","unit","numericValue","hasNullPositions","maxPositionSoFar","i","newPosition","max","lastDefinedIndex","undefined","unpositionedStops","startPosition","endPosition","increment","j"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/react-native/Libraries/StyleSheet/processBackgroundImage.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow strict-local\n */\n\n'use strict';\n\nimport type {ProcessedColorValue} from './processColor';\nimport type {GradientValue} from './StyleSheetTypes';\n\nconst processColor = require('./processColor').default;\nconst DIRECTION_REGEX =\n  /^to\\s+(?:top|bottom|left|right)(?:\\s+(?:top|bottom|left|right))?/;\nconst ANGLE_UNIT_REGEX = /^([+-]?\\d*\\.?\\d+)(deg|grad|rad|turn)$/i;\n\nconst TO_BOTTOM_START_END_POINTS = {\n  start: {x: 0.5, y: 0},\n  end: {x: 0.5, y: 1},\n};\n\ntype ParsedGradientValue = {\n  type: 'linearGradient',\n  start: {x: number, y: number},\n  end: {x: number, y: number},\n  colorStops: $ReadOnlyArray<{\n    color: ProcessedColorValue,\n    position: number,\n  }>,\n};\n\nexport default function processBackgroundImage(\n  backgroundImage: ?($ReadOnlyArray<GradientValue> | string),\n): $ReadOnlyArray<ParsedGradientValue> {\n  let result: $ReadOnlyArray<ParsedGradientValue> = [];\n  if (backgroundImage == null) {\n    return result;\n  }\n\n  if (typeof backgroundImage === 'string') {\n    result = parseCSSLinearGradient(backgroundImage.replace(/\\n/g, ' '));\n  } else if (Array.isArray(backgroundImage)) {\n    for (const bgImage of backgroundImage) {\n      const processedColorStops: Array<{\n        color: ProcessedColorValue,\n        position: number | null,\n      }> = [];\n      for (let index = 0; index < bgImage.colorStops.length; index++) {\n        const colorStop = bgImage.colorStops[index];\n        const processedColor = processColor(colorStop.color);\n        if (processedColor == null) {\n          // If a color is invalid, return an empty array and do not apply gradient. Same as web.\n          return [];\n        }\n        if (colorStop.positions != null && colorStop.positions.length > 0) {\n          for (const position of colorStop.positions) {\n            if (position.endsWith('%')) {\n              processedColorStops.push({\n                color: processedColor,\n                position: parseFloat(position) / 100,\n              });\n            } else {\n              // If a position is invalid, return an empty array and do not apply gradient. Same as web.\n              return [];\n            }\n          }\n        } else {\n          processedColorStops.push({\n            color: processedColor,\n            position: null,\n          });\n        }\n      }\n\n      let points: {\n        start: ParsedGradientValue['start'],\n        end: ParsedGradientValue['end'],\n      } | null = null;\n\n      if (typeof bgImage.direction === 'undefined') {\n        points = TO_BOTTOM_START_END_POINTS;\n      } else if (ANGLE_UNIT_REGEX.test(bgImage.direction)) {\n        const angle = parseAngle(bgImage.direction);\n        if (angle != null) {\n          points = calculateStartEndPointsFromAngle(angle);\n        }\n      } else if (DIRECTION_REGEX.test(bgImage.direction)) {\n        const processedPoints = calculateStartEndPointsFromDirection(\n          bgImage.direction,\n        );\n        if (processedPoints != null) {\n          points = processedPoints;\n        }\n      }\n\n      const fixedColorStops = getFixedColorStops(processedColorStops);\n\n      if (points != null) {\n        result = result.concat({\n          type: 'linearGradient',\n          start: points.start,\n          end: points.end,\n          colorStops: fixedColorStops,\n        });\n      }\n    }\n  }\n\n  return result;\n}\n\nfunction parseCSSLinearGradient(\n  cssString: string,\n): $ReadOnlyArray<ParsedGradientValue> {\n  const gradients = [];\n  let match;\n  const linearGradientRegex = /linear-gradient\\s*\\(((?:\\([^)]*\\)|[^())])*)\\)/gi;\n\n  while ((match = linearGradientRegex.exec(cssString))) {\n    const gradientContent = match[1];\n    const parts = gradientContent.split(',');\n    let points = TO_BOTTOM_START_END_POINTS;\n    const trimmedDirection = parts[0].trim().toLowerCase();\n    const colorStopRegex =\n      /\\s*((?:(?:rgba?|hsla?)\\s*\\([^)]+\\))|#[0-9a-fA-F]+|[a-zA-Z]+)(?:\\s+(-?[0-9.]+%?)(?:\\s+(-?[0-9.]+%?))?)?\\s*/gi;\n\n    if (ANGLE_UNIT_REGEX.test(trimmedDirection)) {\n      const angle = parseAngle(trimmedDirection);\n      if (angle != null) {\n        points = calculateStartEndPointsFromAngle(angle);\n        parts.shift();\n      } else {\n        // If an angle is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (DIRECTION_REGEX.test(trimmedDirection)) {\n      const parsedPoints =\n        calculateStartEndPointsFromDirection(trimmedDirection);\n      if (parsedPoints != null) {\n        points = parsedPoints;\n        parts.shift();\n      } else {\n        // If a direction is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n    } else if (!colorStopRegex.test(trimmedDirection)) {\n      // If first part is not an angle/direction or a color stop, return an empty array and do not apply any gradient. Same as web.\n      return [];\n    }\n    colorStopRegex.lastIndex = 0;\n\n    const colorStops = [];\n    const fullColorStopsStr = parts.join(',');\n    let colorStopMatch;\n    while ((colorStopMatch = colorStopRegex.exec(fullColorStopsStr))) {\n      const [, color, position1, position2] = colorStopMatch;\n      const processedColor = processColor(color.trim().toLowerCase());\n      if (processedColor == null) {\n        // If a color is invalid, return an empty array and do not apply any gradient. Same as web.\n        return [];\n      }\n\n      if (typeof position1 !== 'undefined') {\n        if (position1.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position1) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      } else {\n        colorStops.push({\n          color: processedColor,\n          position: null,\n        });\n      }\n\n      if (typeof position2 !== 'undefined') {\n        if (position2.endsWith('%')) {\n          colorStops.push({\n            color: processedColor,\n            position: parseFloat(position2) / 100,\n          });\n        } else {\n          // If a position is invalid, return an empty array and do not apply any gradient. Same as web.\n          return [];\n        }\n      }\n    }\n\n    const fixedColorStops = getFixedColorStops(colorStops);\n\n    gradients.push({\n      type: 'linearGradient',\n      start: points.start,\n      end: points.end,\n      colorStops: fixedColorStops,\n    });\n  }\n\n  return gradients;\n}\n\nfunction calculateStartEndPointsFromDirection(direction: string): ?{\n  start: {x: number, y: number},\n  end: {x: number, y: number},\n} {\n  // Remove extra whitespace\n  const normalizedDirection = direction.replace(/\\s+/g, ' ');\n\n  switch (normalizedDirection) {\n    case 'to right':\n      return {\n        start: {x: 0, y: 0.5},\n        end: {x: 1, y: 0.5},\n      };\n    case 'to left':\n      return {\n        start: {x: 1, y: 0.5},\n        end: {x: 0, y: 0.5},\n      };\n    case 'to bottom':\n      return TO_BOTTOM_START_END_POINTS;\n    case 'to top':\n      return {\n        start: {x: 0.5, y: 1},\n        end: {x: 0.5, y: 0},\n      };\n    case 'to bottom right':\n    case 'to right bottom':\n      return {\n        start: {x: 0, y: 0},\n        end: {x: 1, y: 1},\n      };\n    case 'to top left':\n    case 'to left top':\n      return {\n        start: {x: 1, y: 1},\n        end: {x: 0, y: 0},\n      };\n    case 'to bottom left':\n    case 'to left bottom':\n      return {\n        start: {x: 1, y: 0},\n        end: {x: 0, y: 1},\n      };\n    case 'to top right':\n    case 'to right top':\n      return {\n        start: {x: 0, y: 1},\n        end: {x: 1, y: 0},\n      };\n    default:\n      return null;\n  }\n}\n\nfunction calculateStartEndPointsFromAngle(angleRadians: number): {\n  start: {x: number, y: number},\n  end: {x: number, y: number},\n} {\n  // Normalize angle to be between 0 and 2π\n  let angleRadiansNormalized = angleRadians % (2 * Math.PI);\n  if (angleRadiansNormalized < 0) {\n    angleRadiansNormalized += 2 * Math.PI;\n  }\n\n  const endX = 0.5 + 0.5 * Math.sin(angleRadiansNormalized);\n  const endY = 0.5 - 0.5 * Math.cos(angleRadiansNormalized);\n\n  const startX = 1 - endX;\n  const startY = 1 - endY;\n\n  return {\n    start: {x: startX, y: startY},\n    end: {x: endX, y: endY},\n  };\n}\n\nfunction parseAngle(angle: string): ?number {\n  const match = angle.match(ANGLE_UNIT_REGEX);\n  if (!match) {\n    return null;\n  }\n\n  const [, value, unit] = match;\n\n  const numericValue = parseFloat(value);\n  switch (unit) {\n    case 'deg':\n      return (numericValue * Math.PI) / 180;\n    case 'grad':\n      return (numericValue * Math.PI) / 200;\n    case 'rad':\n      return numericValue;\n    case 'turn':\n      return numericValue * 2 * Math.PI;\n    default:\n      return null;\n  }\n}\n\n// https://drafts.csswg.org/css-images-4/#color-stop-fixup\nfunction getFixedColorStops(\n  colorStops: $ReadOnlyArray<{\n    color: ProcessedColorValue,\n    position: number | null,\n  }>,\n): Array<{\n  color: ProcessedColorValue,\n  position: number,\n}> {\n  let fixedColorStops: Array<{\n    color: ProcessedColorValue,\n    position: number,\n  }> = [];\n  let hasNullPositions = false;\n  let maxPositionSoFar = colorStops[0].position ?? 0;\n  for (let i = 0; i < colorStops.length; i++) {\n    const colorStop = colorStops[i];\n    let newPosition = colorStop.position;\n    if (newPosition === null) {\n      // Step 1:\n      // If the first color stop does not have a position,\n      // set its position to 0%. If the last color stop does not have a position,\n      // set its position to 100%.\n      if (i === 0) {\n        newPosition = 0;\n      } else if (i === colorStops.length - 1) {\n        newPosition = 1;\n      }\n    }\n    // Step 2:\n    // If a color stop or transition hint has a position\n    // that is less than the specified position of any color stop or transition hint\n    // before it in the list, set its position to be equal to the\n    // largest specified position of any color stop or transition hint before it.\n    if (newPosition !== null) {\n      newPosition = Math.max(newPosition, maxPositionSoFar);\n      fixedColorStops[i] = {\n        color: colorStop.color,\n        position: newPosition,\n      };\n      maxPositionSoFar = newPosition;\n    } else {\n      hasNullPositions = true;\n    }\n  }\n\n  // Step 3:\n  // If any color stop still does not have a position,\n  // then, for each run of adjacent color stops without positions,\n  // set their positions so that they are evenly spaced between the preceding and\n  // following color stops with positions.\n  if (hasNullPositions) {\n    let lastDefinedIndex = 0;\n    for (let i = 1; i < fixedColorStops.length; i++) {\n      if (fixedColorStops[i] !== undefined) {\n        const unpositionedStops = i - lastDefinedIndex - 1;\n        if (unpositionedStops > 0) {\n          const startPosition = fixedColorStops[lastDefinedIndex].position;\n          const endPosition = fixedColorStops[i].position;\n          const increment =\n            (endPosition - startPosition) / (unpositionedStops + 1);\n          for (let j = 1; j <= unpositionedStops; j++) {\n            fixedColorStops[lastDefinedIndex + j] = {\n              color: colorStops[lastDefinedIndex + j].color,\n              position: startPosition + increment * j,\n            };\n          }\n        }\n        lastDefinedIndex = i;\n      }\n    }\n  }\n\n  return fixedColorStops;\n}\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}