{"ast":null,"code":"'use strict';\n\nimport { validateTransform } from \"../../../src/private/animated/NativeAnimatedValidation\";\nimport NativeAnimatedHelper from \"../../../src/private/animated/NativeAnimatedHelper\";\nimport AnimatedNode from \"./AnimatedNode\";\nimport AnimatedWithChildren from \"./AnimatedWithChildren\";\nexport default class AnimatedTransform extends AnimatedWithChildren {\n  #shallowNodes;\n  constructor(transforms) {\n    super();\n    this._transforms = transforms;\n    const shallowNodes = [];\n    if (Array.isArray(transforms)) {\n      for (let ii = 0, length = transforms.length; ii < length; ii++) {\n        const transform = transforms[ii];\n        for (const key in transform) {\n          const value = transform[key];\n          if (value instanceof AnimatedNode) {\n            shallowNodes.push(value);\n          }\n        }\n      }\n    }\n    this.#shallowNodes = shallowNodes;\n  }\n  __makeNative(platformConfig) {\n    const nodes = this.#shallowNodes;\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__makeNative(platformConfig);\n    }\n    super.__makeNative(platformConfig);\n  }\n  __getValue() {\n    return mapTransforms(this._transforms, animatedNode => animatedNode.__getValue());\n  }\n  __getAnimatedValue() {\n    return mapTransforms(this._transforms, animatedNode => animatedNode.__getAnimatedValue());\n  }\n  __attach() {\n    const nodes = this.#shallowNodes;\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__addChild(this);\n    }\n  }\n  __detach() {\n    const nodes = this.#shallowNodes;\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__removeChild(this);\n    }\n    super.__detach();\n  }\n  __getNativeConfig() {\n    const transformsConfig = [];\n    const transforms = this._transforms;\n    for (let ii = 0, length = transforms.length; ii < length; ii++) {\n      const transform = transforms[ii];\n      for (const key in transform) {\n        const value = transform[key];\n        if (value instanceof AnimatedNode) {\n          transformsConfig.push({\n            type: 'animated',\n            property: key,\n            nodeTag: value.__getNativeTag()\n          });\n        } else {\n          transformsConfig.push({\n            type: 'static',\n            property: key,\n            value: NativeAnimatedHelper.transformDataType(value)\n          });\n        }\n      }\n    }\n    if (__DEV__) {\n      validateTransform(transformsConfig);\n    }\n    return {\n      type: 'transform',\n      transforms: transformsConfig\n    };\n  }\n}\nfunction mapTransforms(transforms, mapFunction) {\n  return transforms.map(transform => {\n    const result = {};\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        result[key] = mapFunction(value);\n      } else if (Array.isArray(value)) {\n        result[key] = value.map(element => element instanceof AnimatedNode ? mapFunction(element) : element);\n      } else if (typeof value === 'object') {\n        const object = {};\n        for (const propertyName in value) {\n          const propertyValue = value[propertyName];\n          object[propertyName] = propertyValue instanceof AnimatedNode ? mapFunction(propertyValue) : propertyValue;\n        }\n        result[key] = object;\n      } else {\n        result[key] = value;\n      }\n    }\n    return result;\n  });\n}","map":{"version":3,"names":["validateTransform","NativeAnimatedHelper","AnimatedNode","AnimatedWithChildren","AnimatedTransform","shallowNodes","constructor","transforms","_transforms","Array","isArray","ii","length","transform","key","value","push","__makeNative","platformConfig","nodes","node","__getValue","mapTransforms","animatedNode","__getAnimatedValue","__attach","__addChild","__detach","__removeChild","__getNativeConfig","transformsConfig","type","property","nodeTag","__getNativeTag","transformDataType","__DEV__","mapFunction","map","result","element","object","propertyName","propertyValue"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/react-native/Libraries/Animated/nodes/AnimatedTransform.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n\n'use strict';\n\nimport type {PlatformConfig} from '../AnimatedPlatformConfig';\n\nimport {validateTransform} from '../../../src/private/animated/NativeAnimatedValidation';\nimport NativeAnimatedHelper from '../../../src/private/animated/NativeAnimatedHelper';\nimport AnimatedNode from './AnimatedNode';\nimport AnimatedWithChildren from './AnimatedWithChildren';\n\ntype Transform<T = AnimatedNode> = {\n  [string]:\n    | number\n    | string\n    | T\n    | $ReadOnlyArray<number | string | T>\n    | {[string]: number | string | T},\n};\n\nexport default class AnimatedTransform extends AnimatedWithChildren {\n  // NOTE: For potentially historical reasons, some operations only operate on\n  // the first level of AnimatedNode instances. This optimizes that bevavior.\n  #shallowNodes: $ReadOnlyArray<AnimatedNode>;\n\n  _transforms: $ReadOnlyArray<Transform<>>;\n\n  constructor(transforms: $ReadOnlyArray<Transform<>>) {\n    super();\n    this._transforms = transforms;\n\n    const shallowNodes = [];\n    // NOTE: This check should not be necessary, but the types are not enforced\n    // as of this writing. This check should be hoisted to instantiation sites.\n    if (Array.isArray(transforms)) {\n      for (let ii = 0, length = transforms.length; ii < length; ii++) {\n        const transform = transforms[ii];\n        // There should be exactly one property in `transform`.\n        for (const key in transform) {\n          const value = transform[key];\n          if (value instanceof AnimatedNode) {\n            shallowNodes.push(value);\n          }\n        }\n      }\n    }\n    this.#shallowNodes = shallowNodes;\n  }\n\n  __makeNative(platformConfig: ?PlatformConfig) {\n    const nodes = this.#shallowNodes;\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__makeNative(platformConfig);\n    }\n    super.__makeNative(platformConfig);\n  }\n\n  __getValue(): $ReadOnlyArray<Transform<any>> {\n    return mapTransforms(this._transforms, animatedNode =>\n      animatedNode.__getValue(),\n    );\n  }\n\n  __getAnimatedValue(): $ReadOnlyArray<Transform<any>> {\n    return mapTransforms(this._transforms, animatedNode =>\n      animatedNode.__getAnimatedValue(),\n    );\n  }\n\n  __attach(): void {\n    const nodes = this.#shallowNodes;\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__addChild(this);\n    }\n  }\n\n  __detach(): void {\n    const nodes = this.#shallowNodes;\n    for (let ii = 0, length = nodes.length; ii < length; ii++) {\n      const node = nodes[ii];\n      node.__removeChild(this);\n    }\n    super.__detach();\n  }\n\n  __getNativeConfig(): any {\n    const transformsConfig: Array<any> = [];\n\n    const transforms = this._transforms;\n    for (let ii = 0, length = transforms.length; ii < length; ii++) {\n      const transform = transforms[ii];\n      // There should be exactly one property in `transform`.\n      for (const key in transform) {\n        const value = transform[key];\n        if (value instanceof AnimatedNode) {\n          transformsConfig.push({\n            type: 'animated',\n            property: key,\n            nodeTag: value.__getNativeTag(),\n          });\n        } else {\n          transformsConfig.push({\n            type: 'static',\n            property: key,\n            /* $FlowFixMe[incompatible-call] - `value` can be an array or an\n               object. This is not currently handled by `transformDataType`.\n               Migrating to `TransformObject` might solve this. */\n            value: NativeAnimatedHelper.transformDataType(value),\n          });\n        }\n      }\n    }\n\n    if (__DEV__) {\n      validateTransform(transformsConfig);\n    }\n    return {\n      type: 'transform',\n      transforms: transformsConfig,\n    };\n  }\n}\n\nfunction mapTransforms<T>(\n  transforms: $ReadOnlyArray<Transform<>>,\n  mapFunction: AnimatedNode => T,\n): $ReadOnlyArray<Transform<T>> {\n  return transforms.map(transform => {\n    const result: Transform<T> = {};\n    // There should be exactly one property in `transform`.\n    for (const key in transform) {\n      const value = transform[key];\n      if (value instanceof AnimatedNode) {\n        result[key] = mapFunction(value);\n      } else if (Array.isArray(value)) {\n        result[key] = value.map(element =>\n          element instanceof AnimatedNode ? mapFunction(element) : element,\n        );\n      } else if (typeof value === 'object') {\n        const object: {[string]: number | string | T} = {};\n        for (const propertyName in value) {\n          const propertyValue = value[propertyName];\n          object[propertyName] =\n            propertyValue instanceof AnimatedNode\n              ? mapFunction(propertyValue)\n              : propertyValue;\n        }\n        result[key] = object;\n      } else {\n        result[key] = value;\n      }\n    }\n    return result;\n  });\n}\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}