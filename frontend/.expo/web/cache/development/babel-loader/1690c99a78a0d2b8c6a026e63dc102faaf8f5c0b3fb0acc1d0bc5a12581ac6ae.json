{"ast":null,"code":"import invariant from 'invariant';\nconst NativeModules = require(\"../BatchedBridge/NativeModules\");\nconst turboModuleProxy = global.__turboModuleProxy;\nconst useLegacyNativeModuleInterop = global.RN$Bridgeless !== true || global.RN$TurboInterop === true;\nfunction requireModule(name) {\n  if (turboModuleProxy != null) {\n    const module = turboModuleProxy(name);\n    if (module != null) {\n      return module;\n    }\n  }\n  if (useLegacyNativeModuleInterop) {\n    const legacyModule = NativeModules[name];\n    if (legacyModule != null) {\n      return legacyModule;\n    }\n  }\n  return null;\n}\nexport function get(name) {\n  return requireModule(name);\n}\nexport function getEnforcing(name) {\n  const module = requireModule(name);\n  invariant(module != null, `TurboModuleRegistry.getEnforcing(...): '${name}' could not be found. ` + 'Verify that a module by this name is registered in the native binary.');\n  return module;\n}","map":{"version":3,"names":["invariant","NativeModules","require","turboModuleProxy","global","__turboModuleProxy","useLegacyNativeModuleInterop","RN$Bridgeless","RN$TurboInterop","requireModule","name","module","legacyModule","get","getEnforcing"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/react-native/Libraries/TurboModule/TurboModuleRegistry.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport type {TurboModule} from './RCTExport';\n\nimport invariant from 'invariant';\n\nconst NativeModules = require('../BatchedBridge/NativeModules');\n\nconst turboModuleProxy = global.__turboModuleProxy;\n\nconst useLegacyNativeModuleInterop =\n  global.RN$Bridgeless !== true || global.RN$TurboInterop === true;\n\nfunction requireModule<T: TurboModule>(name: string): ?T {\n  if (turboModuleProxy != null) {\n    const module: ?T = turboModuleProxy(name);\n    if (module != null) {\n      return module;\n    }\n  }\n\n  if (useLegacyNativeModuleInterop) {\n    // Backward compatibility layer during migration.\n    const legacyModule: ?T = NativeModules[name];\n    if (legacyModule != null) {\n      return legacyModule;\n    }\n  }\n\n  return null;\n}\n\nexport function get<T: TurboModule>(name: string): ?T {\n  return requireModule<T>(name);\n}\n\nexport function getEnforcing<T: TurboModule>(name: string): T {\n  const module = requireModule<T>(name);\n  invariant(\n    module != null,\n    `TurboModuleRegistry.getEnforcing(...): '${name}' could not be found. ` +\n      'Verify that a module by this name is registered in the native binary.',\n  );\n  return module;\n}\n"],"mappings":"AAYA,OAAOA,SAAS,MAAM,WAAW;AAEjC,MAAMC,aAAa,GAAGC,OAAO,iCAAiC,CAAC;AAE/D,MAAMC,gBAAgB,GAAGC,MAAM,CAACC,kBAAkB;AAElD,MAAMC,4BAA4B,GAChCF,MAAM,CAACG,aAAa,KAAK,IAAI,IAAIH,MAAM,CAACI,eAAe,KAAK,IAAI;AAElE,SAASC,aAAaA,CAAiBC,IAAY,EAAM;EACvD,IAAIP,gBAAgB,IAAI,IAAI,EAAE;IAC5B,MAAMQ,MAAU,GAAGR,gBAAgB,CAACO,IAAI,CAAC;IACzC,IAAIC,MAAM,IAAI,IAAI,EAAE;MAClB,OAAOA,MAAM;IACf;EACF;EAEA,IAAIL,4BAA4B,EAAE;IAEhC,MAAMM,YAAgB,GAAGX,aAAa,CAACS,IAAI,CAAC;IAC5C,IAAIE,YAAY,IAAI,IAAI,EAAE;MACxB,OAAOA,YAAY;IACrB;EACF;EAEA,OAAO,IAAI;AACb;AAEA,OAAO,SAASC,GAAGA,CAAiBH,IAAY,EAAM;EACpD,OAAOD,aAAa,CAAIC,IAAI,CAAC;AAC/B;AAEA,OAAO,SAASI,YAAYA,CAAiBJ,IAAY,EAAK;EAC5D,MAAMC,MAAM,GAAGF,aAAa,CAAIC,IAAI,CAAC;EACrCV,SAAS,CACPW,MAAM,IAAI,IAAI,EACb,2CAA0CD,IAAK,wBAAuB,GACrE,uEACJ,CAAC;EACD,OAAOC,MAAM;AACf"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}