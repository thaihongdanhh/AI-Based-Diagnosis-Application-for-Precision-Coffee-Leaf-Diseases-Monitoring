{"ast":null,"code":"import _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/objectWithoutPropertiesLoose\";\nconst _excluded = [\"facing\", \"poster\"];\nvar _jsxFileName = \"/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/expo-camera/build/ExpoCamera.web.js\";\nimport { CodedError } from 'expo-modules-core';\nimport { forwardRef, useRef, useMemo, useImperativeHandle } from 'react';\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport createElement from 'react-native-web/dist/exports/createElement';\nimport CameraManager from \"./ExpoCameraManager.web\";\nimport { capture } from \"./web/WebCameraUtils\";\nimport { PictureSizes } from \"./web/WebConstants\";\nimport { useWebCameraStream } from \"./web/useWebCameraStream\";\nimport { useWebQRScanner } from \"./web/useWebQRScanner\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ExponentCamera = forwardRef((_ref, ref) => {\n  let {\n      facing,\n      poster\n    } = _ref,\n    props = _objectWithoutPropertiesLoose(_ref, _excluded);\n  const video = useRef(null);\n  const native = useWebCameraStream(video, facing, props, {\n    onCameraReady() {\n      if (props.onCameraReady) {\n        props.onCameraReady();\n      }\n    },\n    onMountError: props.onMountError\n  });\n  const isQRScannerEnabled = useMemo(() => {\n    return Boolean(props.barcodeScannerSettings?.barcodeTypes?.includes('qr') && !!props.onBarcodeScanned);\n  }, [props.barcodeScannerSettings?.barcodeTypes, props.onBarcodeScanned]);\n  useWebQRScanner(video, {\n    interval: 300,\n    isEnabled: isQRScannerEnabled,\n    captureOptions: {\n      scale: 1,\n      isImageMirror: native.type === 'front'\n    },\n    onScanned(event) {\n      if (props.onBarcodeScanned) {\n        props.onBarcodeScanned(event);\n      }\n    }\n  });\n  useImperativeHandle(ref, () => ({\n    async getAvailablePictureSizes() {\n      return PictureSizes;\n    },\n    async takePicture(options) {\n      if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n        throw new CodedError('ERR_CAMERA_NOT_READY', 'HTMLVideoElement does not have enough camera data to construct an image yet.');\n      }\n      const settings = native.mediaTrackSettings;\n      if (!settings) {\n        throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n      }\n      return capture(video.current, settings, Object.assign({}, options, {\n        onPictureSaved(picture) {\n          if (options.onPictureSaved) {\n            options.onPictureSaved(picture);\n          }\n          if (props.onPictureSaved) {\n            props.onPictureSaved({\n              nativeEvent: {\n                data: picture,\n                id: -1\n              }\n            });\n          }\n        }\n      }));\n    },\n    async resumePreview() {\n      if (video.current) {\n        video.current.play();\n      }\n    },\n    async pausePreview() {\n      if (video.current) {\n        video.current.pause();\n      }\n    }\n  }), [native.mediaTrackSettings, props.onPictureSaved]);\n  const isMuted = true;\n  const style = useMemo(() => {\n    const isFrontFacingCamera = native.type === CameraManager.Type.front;\n    return [StyleSheet.absoluteFill, styles.video, {\n      transform: isFrontFacingCamera ? [{\n        scaleX: -1\n      }] : undefined\n    }];\n  }, [native.type]);\n  return _jsxDEV(View, {\n    pointerEvents: \"box-none\",\n    style: [styles.videoWrapper, props.style],\n    children: [_jsxDEV(Video, {\n      autoPlay: true,\n      playsInline: true,\n      muted: isMuted,\n      poster: poster,\n      pointerEvents: props.pointerEvents,\n      ref: video,\n      style: style\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 84,\n      columnNumber: 9\n    }, this), props.children]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 83,\n    columnNumber: 13\n  }, this);\n});\nexport default ExponentCamera;\nconst Video = forwardRef((props, ref) => createElement('video', Object.assign({}, props, {\n  ref\n})));\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch'\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover'\n  }\n});","map":{"version":3,"names":["CodedError","forwardRef","useRef","useMemo","useImperativeHandle","StyleSheet","View","createElement","CameraManager","capture","PictureSizes","useWebCameraStream","useWebQRScanner","jsxDEV","_jsxDEV","ExponentCamera","_ref","ref","facing","poster","props","_objectWithoutPropertiesLoose","_excluded","video","native","onCameraReady","onMountError","isQRScannerEnabled","Boolean","barcodeScannerSettings","barcodeTypes","includes","onBarcodeScanned","interval","isEnabled","captureOptions","scale","isImageMirror","type","onScanned","event","getAvailablePictureSizes","takePicture","options","current","readyState","HAVE_ENOUGH_DATA","settings","mediaTrackSettings","Object","assign","onPictureSaved","picture","nativeEvent","data","id","resumePreview","play","pausePreview","pause","isMuted","style","isFrontFacingCamera","Type","front","absoluteFill","styles","transform","scaleX","undefined","pointerEvents","videoWrapper","children","Video","autoPlay","playsInline","muted","fileName","_jsxFileName","lineNumber","columnNumber","create","flex","alignItems","width","height","objectFit"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/expo-camera/src/ExpoCamera.web.tsx"],"sourcesContent":["import { CodedError } from 'expo-modules-core';\nimport {\n  type PropsWithChildren,\n  forwardRef,\n  useRef,\n  useMemo,\n  useImperativeHandle,\n  type ComponentProps,\n  type Ref,\n} from 'react';\nimport { StyleProp, StyleSheet, View, ViewStyle } from 'react-native';\nimport createElement from 'react-native-web/dist/exports/createElement';\n\nimport {\n  CameraNativeProps,\n  CameraCapturedPicture,\n  CameraPictureOptions,\n  CameraType,\n} from './Camera.types';\nimport CameraManager from './ExpoCameraManager.web';\nimport { capture } from './web/WebCameraUtils';\nimport { PictureSizes } from './web/WebConstants';\nimport { useWebCameraStream } from './web/useWebCameraStream';\nimport { useWebQRScanner } from './web/useWebQRScanner';\n\nexport interface ExponentCameraRef {\n  getAvailablePictureSizes: (ratio: string) => Promise<string[]>;\n  takePicture: (options: CameraPictureOptions) => Promise<CameraCapturedPicture>;\n  resumePreview: () => Promise<void>;\n  pausePreview: () => Promise<void>;\n}\n\nconst ExponentCamera = forwardRef(\n  (\n    { facing, poster, ...props }: PropsWithChildren<CameraNativeProps>,\n    ref: Ref<ExponentCameraRef>\n  ) => {\n    const video = useRef<HTMLVideoElement | null>(null);\n\n    const native = useWebCameraStream(video, facing as CameraType, props, {\n      onCameraReady() {\n        if (props.onCameraReady) {\n          props.onCameraReady();\n        }\n      },\n      onMountError: props.onMountError,\n    });\n\n    const isQRScannerEnabled = useMemo<boolean>(() => {\n      return Boolean(\n        props.barcodeScannerSettings?.barcodeTypes?.includes('qr') && !!props.onBarcodeScanned\n      );\n    }, [props.barcodeScannerSettings?.barcodeTypes, props.onBarcodeScanned]);\n\n    useWebQRScanner(video, {\n      interval: 300,\n      isEnabled: isQRScannerEnabled,\n      captureOptions: { scale: 1, isImageMirror: native.type === 'front' },\n      onScanned(event) {\n        if (props.onBarcodeScanned) {\n          props.onBarcodeScanned(event);\n        }\n      },\n    });\n\n    useImperativeHandle(\n      ref,\n      () => ({\n        async getAvailablePictureSizes(): Promise<string[]> {\n          return PictureSizes;\n        },\n        async takePicture(options: CameraPictureOptions): Promise<CameraCapturedPicture> {\n          if (!video.current || video.current?.readyState !== video.current?.HAVE_ENOUGH_DATA) {\n            throw new CodedError(\n              'ERR_CAMERA_NOT_READY',\n              'HTMLVideoElement does not have enough camera data to construct an image yet.'\n            );\n          }\n          const settings = native.mediaTrackSettings;\n          if (!settings) {\n            throw new CodedError('ERR_CAMERA_NOT_READY', 'MediaStream is not ready yet.');\n          }\n\n          return capture(video.current, settings, {\n            ...options,\n            // This will always be defined, the option gets added to a queue in the upper-level. We should replace the original so it isn't called twice.\n            onPictureSaved(picture) {\n              if (options.onPictureSaved) {\n                options.onPictureSaved(picture);\n              }\n              if (props.onPictureSaved) {\n                props.onPictureSaved({ nativeEvent: { data: picture, id: -1 } });\n              }\n            },\n          });\n        },\n        async resumePreview(): Promise<void> {\n          if (video.current) {\n            video.current.play();\n          }\n        },\n        async pausePreview(): Promise<void> {\n          if (video.current) {\n            video.current.pause();\n          }\n        },\n      }),\n      [native.mediaTrackSettings, props.onPictureSaved]\n    );\n\n    // TODO(Bacon): Create a universal prop, on native the microphone is only used when recording videos.\n    // Because we don't support recording video in the browser we don't need the user to give microphone permissions.\n    const isMuted = true;\n\n    const style = useMemo<StyleProp<ViewStyle>>(() => {\n      const isFrontFacingCamera = native.type === CameraManager.Type.front;\n      return [\n        StyleSheet.absoluteFill,\n        styles.video,\n        {\n          // Flip the camera\n          transform: isFrontFacingCamera ? [{ scaleX: -1 }] : undefined,\n        },\n      ];\n    }, [native.type]);\n\n    return (\n      <View pointerEvents=\"box-none\" style={[styles.videoWrapper, props.style]}>\n        <Video\n          autoPlay\n          playsInline\n          muted={isMuted}\n          poster={poster}\n          pointerEvents={props.pointerEvents}\n          ref={video}\n          style={style}\n        />\n        {props.children}\n      </View>\n    );\n  }\n);\n\nexport default ExponentCamera;\n\nconst Video = forwardRef(\n  (\n    props: ComponentProps<typeof View> & {\n      autoPlay?: boolean;\n      playsInline?: boolean;\n      muted?: boolean;\n      poster?: string;\n    },\n    ref: Ref<HTMLVideoElement>\n  ) => createElement('video', { ...props, ref })\n);\n\nconst styles = StyleSheet.create({\n  videoWrapper: {\n    flex: 1,\n    alignItems: 'stretch',\n  },\n  video: {\n    width: '100%',\n    height: '100%',\n    objectFit: 'cover',\n  },\n});\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}