{"ast":null,"code":"import * as TurboModuleRegistry from \"../../../../../../Libraries/TurboModule/TurboModuleRegistry\";\nimport nullthrows from 'nullthrows';\nconst RawNativeDOM = TurboModuleRegistry.get('NativeDOMCxx');\nconst NativeDOM = {\n  getParentNode(shadowNode) {\n    return nullthrows(RawNativeDOM).getParentNode(shadowNode);\n  },\n  getChildNodes(shadowNode) {\n    return nullthrows(RawNativeDOM).getChildNodes(shadowNode);\n  },\n  isConnected(shadowNode) {\n    return nullthrows(RawNativeDOM).isConnected(shadowNode);\n  },\n  compareDocumentPosition(shadowNode, otherShadowNode) {\n    return nullthrows(RawNativeDOM).compareDocumentPosition(shadowNode, otherShadowNode);\n  },\n  getTextContent(shadowNode) {\n    return nullthrows(RawNativeDOM).getTextContent(shadowNode);\n  },\n  getBoundingClientRect(shadowNode, includeTransform) {\n    return nullthrows(RawNativeDOM).getBoundingClientRect(shadowNode, includeTransform);\n  },\n  getOffset(shadowNode) {\n    return nullthrows(RawNativeDOM).getOffset(shadowNode);\n  },\n  getScrollPosition(shadowNode) {\n    return nullthrows(RawNativeDOM).getScrollPosition(shadowNode);\n  },\n  getScrollSize(shadowNode) {\n    return nullthrows(RawNativeDOM).getScrollSize(shadowNode);\n  },\n  getInnerSize(shadowNode) {\n    return nullthrows(RawNativeDOM).getInnerSize(shadowNode);\n  },\n  getBorderWidth(shadowNode) {\n    return nullthrows(RawNativeDOM).getBorderWidth(shadowNode);\n  },\n  getTagName(shadowNode) {\n    return nullthrows(RawNativeDOM).getTagName(shadowNode);\n  },\n  hasPointerCapture(shadowNode, pointerId) {\n    return nullthrows(RawNativeDOM).hasPointerCapture(shadowNode, pointerId);\n  },\n  setPointerCapture(shadowNode, pointerId) {\n    return nullthrows(RawNativeDOM).setPointerCapture(shadowNode, pointerId);\n  },\n  releasePointerCapture(shadowNode, pointerId) {\n    return nullthrows(RawNativeDOM).releasePointerCapture(shadowNode, pointerId);\n  },\n  measure(shadowNode, callback) {\n    return nullthrows(RawNativeDOM).measure(shadowNode, callback);\n  },\n  measureInWindow(shadowNode, callback) {\n    return nullthrows(RawNativeDOM).measureInWindow(shadowNode, callback);\n  },\n  measureLayout(shadowNode, relativeNode, onFail, onSuccess) {\n    return nullthrows(RawNativeDOM).measureLayout(shadowNode, relativeNode, onFail, onSuccess);\n  }\n};\nexport default NativeDOM;","map":{"version":3,"names":["TurboModuleRegistry","nullthrows","RawNativeDOM","get","NativeDOM","getParentNode","shadowNode","getChildNodes","isConnected","compareDocumentPosition","otherShadowNode","getTextContent","getBoundingClientRect","includeTransform","getOffset","getScrollPosition","getScrollSize","getInnerSize","getBorderWidth","getTagName","hasPointerCapture","pointerId","setPointerCapture","releasePointerCapture","measure","callback","measureInWindow","measureLayout","relativeNode","onFail","onSuccess"],"sources":["/home/data2/AIFace/AICoffeeLeaf/frontend/node_modules/react-native/src/private/webapis/dom/nodes/specs/NativeDOM.js"],"sourcesContent":["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow strict\n * @format\n */\n\nimport type {\n  InternalInstanceHandle as InstanceHandle,\n  Node as ShadowNode,\n} from '../../../../../../Libraries/Renderer/shims/ReactNativeTypes';\nimport type {TurboModule} from '../../../../../../Libraries/TurboModule/RCTExport';\n\nimport * as TurboModuleRegistry from '../../../../../../Libraries/TurboModule/TurboModuleRegistry';\nimport nullthrows from 'nullthrows';\n\nexport type MeasureInWindowOnSuccessCallback = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n) => void;\n\nexport type MeasureOnSuccessCallback = (\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  pageX: number,\n  pageY: number,\n) => void;\n\nexport type MeasureLayoutOnSuccessCallback = (\n  left: number,\n  top: number,\n  width: number,\n  height: number,\n) => void;\n\nexport interface Spec extends TurboModule {\n  +getParentNode: (\n    shadowNode: mixed /* ShadowNode */,\n  ) => mixed /* ?InstanceHandle */;\n\n  +getChildNodes: (\n    shadowNode: mixed /* ShadowNode */,\n  ) => $ReadOnlyArray<mixed> /* $ReadOnlyArray<InstanceHandle> */;\n\n  +isConnected: (shadowNode: mixed /* ShadowNode */) => boolean;\n\n  +compareDocumentPosition: (\n    shadowNode: mixed /* ShadowNode */,\n    otherShadowNode: mixed /* ShadowNode */,\n  ) => number;\n\n  +getTextContent: (shadowNode: mixed /* ShadowNode */) => string;\n\n  +getBoundingClientRect: (\n    shadowNode: mixed /* ShadowNode */,\n    includeTransform: boolean,\n  ) => $ReadOnlyArray<number> /* [x: number, y: number, width: number, height: number] */;\n\n  +getOffset: (\n    shadowNode: mixed /* ShadowNode */,\n  ) => $ReadOnlyArray<mixed> /* [offsetParent: ?InstanceHandle, top: number, left: number] */;\n\n  +getScrollPosition: (\n    shadowNode: mixed /* ShadowNode */,\n  ) => $ReadOnlyArray<number> /* [scrollLeft: number, scrollTop: number] */;\n\n  +getScrollSize: (\n    shadowNode: mixed /* ShadowNode */,\n  ) => $ReadOnlyArray<number> /* [scrollWidth: number, scrollHeight: number] */;\n\n  +getInnerSize: (\n    shadowNode: mixed /* ShadowNode */,\n  ) => $ReadOnlyArray<number> /* [width: number, height: number] */;\n\n  +getBorderWidth: (\n    shadowNode: mixed /* ShadowNode */,\n  ) => $ReadOnlyArray<number> /* [topWidth: number, rightWidth: number, bottomWidth: number, leftWidth: number] */;\n\n  +getTagName: (shadowNode: mixed /* ShadowNode */) => string;\n\n  +hasPointerCapture: (\n    shadowNode: mixed /* ShadowNode */,\n    pointerId: number,\n  ) => boolean;\n\n  +setPointerCapture: (\n    shadowNode: mixed /* ShadowNode */,\n    pointerId: number,\n  ) => void;\n\n  +releasePointerCapture: (\n    shadowNode: mixed /* ShadowNode */,\n    pointerId: number,\n  ) => void;\n\n  /**\n   * Legacy layout APIs\n   */\n\n  +measure: (shadowNode: mixed, callback: MeasureOnSuccessCallback) => void;\n\n  +measureInWindow: (\n    shadowNode: mixed,\n    callback: MeasureInWindowOnSuccessCallback,\n  ) => void;\n\n  +measureLayout: (\n    shadowNode: mixed,\n    relativeNode: mixed,\n    onFail: () => void,\n    onSuccess: MeasureLayoutOnSuccessCallback,\n  ) => void;\n}\n\nconst RawNativeDOM = (TurboModuleRegistry.get<Spec>('NativeDOMCxx'): ?Spec);\n\n// This is the actual interface of this module, but the native module codegen\n// isn't expressive enough yet.\nexport interface RefinedSpec {\n  /**\n   * This is a React Native implementation of `Node.prototype.parentNode`\n   * (see https://developer.mozilla.org/en-US/docs/Web/API/Node/parentNode).\n   *\n   * If a version of the given shadow node is present in the current revision of\n   * an active shadow tree, it returns the instance handle of its parent.\n   * Otherwise, it returns `null`.\n   */\n  +getParentNode: (shadowNode: ShadowNode) => ?InstanceHandle;\n\n  /**\n   * This is a React Native implementation of `Node.prototype.childNodes`\n   * (see https://developer.mozilla.org/en-US/docs/Web/API/Node/childNodes).\n   *\n   * If a version of the given shadow node is present in the current revision\n   * of an active shadow tree, it returns an array of instance handles of its\n   * children. Otherwise, it returns an empty array.\n   */\n  +getChildNodes: (shadowNode: ShadowNode) => $ReadOnlyArray<InstanceHandle>;\n\n  /**\n   * This is a React Native implementation of `Node.prototype.isConnected`\n   * (see https://developer.mozilla.org/en-US/docs/Web/API/Node/isConnected).\n   *\n   * Indicates whether a version of the given shadow node is present in the\n   * current revision of an active shadow tree.\n   */\n  +isConnected: (shadowNode: ShadowNode) => boolean;\n\n  /**\n   * This is a React Native implementation of `Node.prototype.compareDocumentPosition`\n   * (see https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition).\n   *\n   * It uses the version of the shadow nodes that are present in the current\n   * revision of the shadow tree (if any). If any of the nodes is not present,\n   * it just indicates they are disconnected.\n   */\n  +compareDocumentPosition: (\n    shadowNode: ShadowNode,\n    otherShadowNode: ShadowNode,\n  ) => number;\n\n  /**\n   * This is a React Native implementation of `Element.prototype.textContent`\n   * (see https://developer.mozilla.org/en-US/docs/Web/API/Element/textContent).\n   *\n   * It uses the version of the shadow node that is present in the current\n   * revision of the shadow tree.\n   * If the version is present, is traverses all its children in DFS and\n   * concatenates all the text contents. Otherwise, it returns an empty string.\n   *\n   * This is also used to access the text content of text nodes, which does not\n   * need any traversal.\n   */\n  +getTextContent: (shadowNode: ShadowNode) => string;\n\n  /**\n   * This is a React Native implementation of `Element.prototype.getBoundingClientRect`\n   * (see https://developer.mozilla.org/en-US/docs/Web/API/Element/getBoundingClientRect).\n   *\n   * This is similar to `measureInWindow`, except it's explicitly synchronous\n   * (returns the result instead of passing it to a callback).\n   *\n   * It allows indicating whether to include transforms so it can also be used\n   * to implement methods like [`offsetWidth`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetWidth)\n   * and [`offsetHeight`](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight).\n   */\n  +getBoundingClientRect: (\n    shadowNode: ShadowNode,\n    includeTransform: boolean,\n  ) => $ReadOnly<\n    [\n      /* x: */ number,\n      /* y: */ number,\n      /* width: */ number,\n      /* height: */ number,\n    ],\n  >;\n\n  /**\n   * This is a method to access the offset information for a shadow node, to\n   * implement these methods:\n   *   - `HTMLElement.prototype.offsetParent`: see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetParent.\n   *   - `HTMLElement.prototype.offsetTop`: see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetTop.\n   *   - `HTMLElement.prototype.offsetLeft`: see https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetLeft.\n   *\n   * It uses the version of the shadow node that is present in the current\n   * revision of the shadow tree. If the node is not present or is not\n   * displayed (because any of its ancestors or itself have 'display: none'),\n   * it returns `undefined`. Otherwise, it returns its parent (as all nodes in\n   * React Native are currently \"positioned\") and its offset relative to its\n   * parent.\n   */\n  +getOffset: (\n    shadowNode: ShadowNode,\n  ) => $ReadOnly<\n    [\n      /* offsetParent: */ ?InstanceHandle,\n      /* top: */ number,\n      /* left: */ number,\n    ],\n  >;\n\n  /**\n   * This is a method to access scroll information for a shadow node, to\n   * implement these methods:\n   *   - `Element.prototype.scrollLeft`: see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollLeft.\n   *   - `Element.prototype.scrollTop`: see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollTop.\n   *\n   * It uses the version of the shadow node that is present in the current\n   * revision of the shadow tree. If the node is not present or is not displayed\n   * (because any of its ancestors or itself have 'display: none'), it returns\n   * `undefined`. Otherwise, it returns the scroll position.\n   */\n  +getScrollPosition: (\n    shadowNode: ShadowNode,\n  ) => $ReadOnly<[/* scrollLeft: */ number, /* scrollTop: */ number]>;\n\n  /**\n   *\n   * This is a method to access the scroll information of a shadow node, to\n   * implement these methods:\n   *   - `Element.prototype.scrollWidth`: see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollWidth.\n   *   - `Element.prototype.scrollHeight`: see https://developer.mozilla.org/en-US/docs/Web/API/Element/scrollHeight.\n   *\n   * It uses the version of the shadow node that is present in the current\n   * revision of the shadow tree. If the node is not present or is not displayed\n   * (because any of its ancestors or itself have 'display: none'), it returns\n   * `undefined`. Otherwise, it returns the scroll size.\n   */\n  +getScrollSize: (\n    shadowNode: ShadowNode,\n  ) => $ReadOnly<[/* scrollWidth: */ number, /* scrollHeight: */ number]>;\n\n  /**\n   * This is a method to access the inner size of a shadow node, to implement\n   * these methods:\n   *   - `Element.prototype.clientWidth`: see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientWidth.\n   *   - `Element.prototype.clientHeight`: see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientHeight.\n   *\n   * It uses the version of the shadow node that is present in the current\n   * revision of the shadow tree. If the node is not present, it is not\n   * displayed (because any of its ancestors or itself have 'display: none'), or\n   * it has an inline display, it returns `undefined`. Otherwise, it returns its\n   * inner size.\n   */\n  +getInnerSize: (\n    shadowNode: ShadowNode,\n  ) => $ReadOnly<[/* width: */ number, /* height: */ number]>;\n\n  /**\n   * This is a method to access the border size of a shadow node, to implement\n   * these methods:\n   *   - `Element.prototype.clientLeft`: see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientLeft.\n   *   - `Element.prototype.clientTop`: see https://developer.mozilla.org/en-US/docs/Web/API/Element/clientTop.\n   *\n   * It uses the version of the shadow node that is present in the current\n   * revision of the shadow tree. If the node is not present, it is not\n   * displayed (because any of its ancestors or itself have 'display: none'), or\n   * it has an inline display, it returns `undefined`. Otherwise, it returns its\n   * border size.\n   */\n  +getBorderWidth: (\n    shadowNode: ShadowNode,\n  ) => $ReadOnly<\n    [\n      /* topWidth: */ number,\n      /* rightWidth: */ number,\n      /* bottomWidth: */ number,\n      /* leftWidth: */ number,\n    ],\n  >;\n\n  /**\n   * This is a method to access the normalized tag name of a shadow node, to\n   * implement `Element.prototype.tagName` (see https://developer.mozilla.org/en-US/docs/Web/API/Element/tagName).\n   */\n  +getTagName: (shadowNode: ShadowNode) => string;\n\n  /**\n   * Pointer Capture APIs\n   */\n\n  +hasPointerCapture: (shadowNode: ShadowNode, pointerId: number) => boolean;\n\n  +setPointerCapture: (shadowNode: ShadowNode, pointerId: number) => void;\n\n  +releasePointerCapture: (shadowNode: ShadowNode, pointerId: number) => void;\n\n  /**\n   * Legacy layout APIs\n   */\n\n  +measure: (\n    shadowNode: ShadowNode,\n    callback: MeasureOnSuccessCallback,\n  ) => void;\n\n  +measureInWindow: (\n    shadowNode: ShadowNode,\n    callback: MeasureInWindowOnSuccessCallback,\n  ) => void;\n\n  +measureLayout: (\n    shadowNode: ShadowNode,\n    relativeNode: ShadowNode,\n    onFail: () => void,\n    onSuccess: MeasureLayoutOnSuccessCallback,\n  ) => void;\n}\n\nconst NativeDOM: RefinedSpec = {\n  getParentNode(shadowNode) {\n    // $FlowExpectedError[incompatible-cast]\n    return (nullthrows(RawNativeDOM).getParentNode(\n      shadowNode,\n    ): ?InstanceHandle);\n  },\n\n  getChildNodes(shadowNode) {\n    // $FlowExpectedError[incompatible-cast]\n    return (nullthrows(RawNativeDOM).getChildNodes(\n      shadowNode,\n    ): $ReadOnlyArray<InstanceHandle>);\n  },\n\n  isConnected(shadowNode) {\n    return nullthrows(RawNativeDOM).isConnected(shadowNode);\n  },\n\n  compareDocumentPosition(shadowNode, otherShadowNode) {\n    return nullthrows(RawNativeDOM).compareDocumentPosition(\n      shadowNode,\n      otherShadowNode,\n    );\n  },\n\n  getTextContent(shadowNode) {\n    return nullthrows(RawNativeDOM).getTextContent(shadowNode);\n  },\n\n  getBoundingClientRect(shadowNode, includeTransform: boolean) {\n    // $FlowExpectedError[incompatible-cast]\n    return (nullthrows(RawNativeDOM).getBoundingClientRect(\n      shadowNode,\n      includeTransform,\n    ): $ReadOnly<\n      [\n        /* x: */ number,\n        /* y: */ number,\n        /* width: */ number,\n        /* height: */ number,\n      ],\n    >);\n  },\n\n  getOffset(shadowNode) {\n    // $FlowExpectedError[incompatible-cast]\n    return (nullthrows(RawNativeDOM).getOffset(shadowNode): $ReadOnly<\n      [\n        /* offsetParent: */ ?InstanceHandle,\n        /* top: */ number,\n        /* left: */ number,\n      ],\n    >);\n  },\n\n  getScrollPosition(shadowNode) {\n    // $FlowExpectedError[incompatible-cast]\n    return (nullthrows(RawNativeDOM).getScrollPosition(shadowNode): $ReadOnly<\n      [/* scrollLeft: */ number, /* scrollTop: */ number],\n    >);\n  },\n\n  getScrollSize(shadowNode) {\n    // $FlowExpectedError[incompatible-cast]\n    return (nullthrows(RawNativeDOM).getScrollSize(shadowNode): $ReadOnly<\n      [/* scrollWidth: */ number, /* scrollHeight: */ number],\n    >);\n  },\n\n  getInnerSize(shadowNode) {\n    // $FlowExpectedError[incompatible-cast]\n    return (nullthrows(RawNativeDOM).getInnerSize(shadowNode): $ReadOnly<\n      [/* width: */ number, /* height: */ number],\n    >);\n  },\n\n  getBorderWidth(shadowNode) {\n    // $FlowExpectedError[incompatible-cast]\n    return (nullthrows(RawNativeDOM).getBorderWidth(shadowNode): $ReadOnly<\n      [\n        /* topWidth: */ number,\n        /* rightWidth: */ number,\n        /* bottomWidth: */ number,\n        /* leftWidth: */ number,\n      ],\n    >);\n  },\n\n  getTagName(shadowNode) {\n    return nullthrows(RawNativeDOM).getTagName(shadowNode);\n  },\n\n  hasPointerCapture(shadowNode, pointerId) {\n    return nullthrows(RawNativeDOM).hasPointerCapture(shadowNode, pointerId);\n  },\n\n  setPointerCapture(shadowNode, pointerId) {\n    return nullthrows(RawNativeDOM).setPointerCapture(shadowNode, pointerId);\n  },\n\n  releasePointerCapture(shadowNode, pointerId) {\n    return nullthrows(RawNativeDOM).releasePointerCapture(\n      shadowNode,\n      pointerId,\n    );\n  },\n\n  /**\n   * Legacy layout APIs\n   */\n\n  measure(shadowNode, callback) {\n    return nullthrows(RawNativeDOM).measure(shadowNode, callback);\n  },\n\n  measureInWindow(shadowNode, callback) {\n    return nullthrows(RawNativeDOM).measureInWindow(shadowNode, callback);\n  },\n\n  measureLayout(shadowNode, relativeNode, onFail, onSuccess) {\n    return nullthrows(RawNativeDOM).measureLayout(\n      shadowNode,\n      relativeNode,\n      onFail,\n      onSuccess,\n    );\n  },\n};\n\nexport default NativeDOM;\n"],"mappings":"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"},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}